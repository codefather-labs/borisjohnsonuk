Multithreading Python ceval.c  line 480 PyThreadState * PyEval_SaveThread( void ) { PyThreadState *tstate = PyThreadState_Swap(NULL); if  (tstate == NULL) Py_FatalError( "PyEval_SaveThread: NULL tstate" ); assert(gil_created()); drop_gil(tstate); return  tstate; } Because the GIL is dropped, it means any other executing thread can continue. This thread will sit and wait for the system call without blocking the evaluation loop. Once the  connect()  function has succeeded or timed out, the  Py_END_- ALLOW_THREADS  runs the  PyEval_RestoreThread()  function with the original thread state. The thread state is recovered and the GIL is retaken. The call to  take_- gil()  is a blocking call, waiting on a semaphore: Python ceval.c  line 503 void PyEval_RestoreThread(PyThreadState *tstate) { if  (tstate == NULL) Py_FatalError( "PyEval_RestoreThread: NULL tstate" ); assert(gil_created()); int  err = errno; take_gil(tstate); /* _Py_Finalizing is protected by the GIL */ if  (_Py_IsFinalizing() && !_Py_CURRENTLY_FINALIZING(tstate)) { drop_gil(tstate); PyThread_exit_thread(); 262
Coroutines loop  =  asyncio.new_event_loop() Inside a loop is a sequence of tasks, represented by the type asyncio.Task , tasks are scheduled onto a loop, then once the loop is running, it loops over all the tasks until they complete. You can convert the single timer into a task loop: cpython-book-samples 33 sleepy_alarm.py import  asyncio async def  sleepy_alarm(person, time): await  asyncio.sleep(time) print( f" { person }  -- wake up!" ) async def  wake_up_gang(): tasks  =  [ asyncio.create_task(sleepy_alarm( "Bob" ,  3 ), name = "wake up Bob" ), asyncio.create_task(sleepy_alarm( "Sanjeet" ,  4 ), name = "wake up Sanjeet" ), asyncio.create_task(sleepy_alarm( "Doris" ,  2 ), name = "wake up Doris" ), asyncio.create_task(sleepy_alarm( "Kim" ,  5 ), name = "wake up Kim" ) ] await  asyncio.gather( * tasks) asyncio.run(wake_up_gang()) This will print: Doris -- wake up! Bob -- wake up! Sanjeet -- wake up! Kim -- wake up! In the event loop, it will run over each of the coroutines to see if they are completed. Similar to how the  yield  keyword can return multiple values from the same frame, the  await  keyword can return multiple states. The event loop will execute the  sleepy_alarm()  coroutine objects again and again until the  await asyncio.sleep()  yields a completed re- 279
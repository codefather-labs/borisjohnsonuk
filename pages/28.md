If you run a bunch of ThreadBots over a bunch of tables a specific number of times, you expect that after all the work is done, all of the knives and forks should be back in the kitchen and accounted for. Wisely, you decide to test that, with one hundred tables to be prepared and cleared by each ThreadBot and all of them operating at the same time, because you want to ensure that they can work together and nothing goes wrong. This is the output of that test: `$ ` `python cutlery_test.py 100` `Kitchen inventory before service: Cutlery(knives=100, forks=100)` `Kitchen inventory after service: Cutlery(knives=100, forks=100)` All the knives and forks end up back in the kitchen! So, you congratulate yourself on writing good code and deploy the bots. Unfortunately,  *in practice* , every now and then you find that you  *do not*  end up with all cutlery accounted for when the restaurant closes. You notice the problem gets worse when you add more bots and/or the place gets busier. Frustrated, you run your tests again, changing nothing except the size of the test (10,000 tables!): `$ ` `python cutlery_test.py 10000` `Kitchen inventory before service: Cutlery(knives=100, forks=100)` `Kitchen inventory after service: Cutlery(knives=96, forks=108)` Oops. Now you see that there is indeed a problem. With 10,000 tables served, you end up with the wrong number of knives and forks left in the kitchen. For reproducibility, you check that the error is consistent: `$ ` `python cutlery_test.py 10000` `Kitchen inventory before service: Cutlery(knives=100, forks=100)` `Kitchen inventory after service: Cutlery(knives=112, forks=96)` There are still errors, but  *by * *different* * amounts*  compared to the previous run. That’s just ridiculous! Remember, these bots are exceptionally well constructed and they don’t make mistakes. What could be going wrong? Let’s summarize the situation: •  Your ThreadBot code is very simple and easy to read. The logic is fine. •  You have a working test (with 100 tables) that reproducibly passes. •  You have a longer test (with 10,000 tables) that reproducibly fails. •  The longer test fails in  *different,* * nonreproducible ways* . These are a few typical signs of a race condition bug. Experienced readers will already have seen the cause, so let’s investigate that now. It all comes down to this method inside our  `Cutlery`  class: **Case Study: Robots and Cutlery ** **| ** **17**
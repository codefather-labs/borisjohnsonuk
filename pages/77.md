10 ` add_signal_handler()`  should probably be named  `set_signal_handler()` , since you can have only one handler per signal type; calling  `add_signal_handler()`  a second time for the same signal will replace the existing handler for that signal. `    ` `loop` `.` `create_task` `(` `main` `())` `    ` `loop` `.` `run_forever` `()` `  ` `    ` `tasks` ` ` `=` ` ` `asyncio` `.` `all_tasks` `(` `loop` `=` `loop` `)` `    ` `for` ` ` `t` ` ` `in` ` ` `tasks` `:` `        ` `t` `.` `cancel` `()` `    ` `group` ` ` `=` ` ` `asyncio` `.` `gather` `(` `*` `tasks` `,` ` ` `return_exceptions` `=` `True` `)` `    ` `loop` `.` `run_until_complete` `(` `group` `)` `    ` `loop` `.` `close` `()` Import the signal values from the standard library  `signal`  module. This time, our  `main()`  coroutine is going to do some cleanup internally. When the cancellation signal is received (initiated by cancelling each of the tasks), there will be a period of 3 seconds where  `main()`  will continue running during the `run_until_complete()`  phase of the shutdown process. It’ll print, “Your app is shutting down…”. This is a callback handler for when we receive a signal. It is configured on the loop via the call to  `add_signal_handler()`  a bit farther down. The primary purpose of the handler is to stop the loop: this will unblock the `loop.run_forever()`  call and allow pending task collection and cancellation, and the  `run_complete()`  for shutdown. Since we are now in shutdown mode, we  *don’t want*  another  `SIGINT`  or  `SIGTERM` to trigger this handler again: that would call  `loop.stop()`  during the `run_until_complete()`  phase, which would interfere with our shutdown process. Therefore, we  *remove*  the signal handler for  `SIGTERM`  from the loop. This is a “gotcha”: we can’t simply remove the handler for  `SIGINT` , because if we did that,  `KeyboardInterrupt`  would again become the handler for  `SIGINT` , the same as it was before we added our own handlers. Instead, we set an empty `lambda`  function as the handler. This means that  `KeyboardInterrupt`  stays away, and  `SIGINT`  (and Ctrl-C) has no effect. 10 Here the signal handlers are attached to the loop. Note that, as discussed previously, setting a handler on  `SIGINT`  means a  `KeyboardInterrupt`  will no longer be raised on  `SIGINT` . The raising of a  `KeyboardInterrupt`  is the “default” handler for **66 ** **| ** **Chapter 3: Asyncio Walk-Through**
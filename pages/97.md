`try` `:` `    ` `asyncio` `.` `run` `(` `main` `(` `client` `,` ` ` `host` `=` `'127.0.0.1'` `,` ` ` `port` `=` `25000` `))` `except` ` ` `KeyboardInterrupt` `:` `    ` `print` `(` `'Bye!'` `)` In the previous implementation, there were only  `SUBSCRIBERS` ; now there are `SEND_QUEUES`  and  `CHAN_QUEUES`  as global collections. This is a consequence of completely decoupling the  *receiving*  and  *sending*  of data.  `SEND_QUEUES`  has one queue entry for each client connection: all data that must be sent to that client must be placed onto that queue. (If you peek ahead, the  `send_client()`  coroutine will pull data off  `SEND_QUEUES`  and send it.) Up until this point in the  `client()`  coroutine function, the code is the same as in the simple server: the subscribed channel name is received, and we add the `StreamWriter`  instance for the new client to the global  `SUBSCRIBERS`  collection. This is new: we create a long-lived task that will do all the sending of data to this client. The task will run independently as a separate coroutine and will pull messages off the supplied queue,  `SEND_QUEUES[writer]` , for sending. Now we’re inside the loop where we receive data. Remember that we always receive two messages: one for the destination channel name, and one for the data. We’re going to create a new, dedicated  `Queue`  for every destination channel, and that’s what  `CHAN_QUEUES`  is for: when any client wants to push data to a channel, we’re going to put that data onto the appropriate queue and then go immediately back to listening for more data. This approach decouples the distribution of messages from the receiving of messages from this client. If there isn’t already a queue for the target channel, make one. Create a dedicated and long-lived task for that channel. The coroutine `chan_sender()`  will be responsible for taking data off the channel queue and distributing that data to subscribers. Place the newly received data onto the specific channel’s queue. If the queue fills up, we’ll wait here until there is space for the new data. Waiting here means we won’t be reading any new data off the socket, which means that the client will have to wait on sending new data into the socket on its side. This isn’t necessarily a bad thing, since it communicates so-called  *back-pressure*  to this client. (Alternatively, you could choose to drop messages here if the use case is OK with that.) When the connection is closed, it’s time to clean up. The long-lived task we created for sending data to this client,  `send_task` , can be shut down by placing  `None` **86 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
### Benefits
 ###  of Threading
 These are the main benefits of threading: *Ease of reading code* Your code can run concurrently, but still be set out in a very simple, top-down linear sequence of commands to the point where—and this is key—you can pretend, within the body of your functions, that no concurrency is happening. *Parallelism with shared memory* Your code can exploit multiple CPUs while still having threads share memory. This is important in many workloads where it would be too costly to move large amounts of data between the separate memory spaces of different processes, for example. *Know-how and existing code* There is a large body of knowledge and best practices available for writing threaded applications. There is also a huge amount of existing “blocking” code that depends on multithreading for concurrent operation. Now, with  *Python* , the point about parallelism is questionable because the Python interpreter uses a global lock, called the  *global interpreter lock*  (GIL), to protect the internal state of the interpreter itself. That is, it provides protection from the potential catastrophic effects of race conditions between multiple threads. A side effect of the lock is that it ends up pinning all threads in your program to a single CPU. As you might imagine, this negates any parallelism performance benefits (unless you use tools like Cython or Numba to maneuver around the limitation). The first point regarding perceived simplicity, however, is significant: threading in Python  *feels*  exceptionally simple, and if you haven’t been burned before by impossibly hard race condition bugs, threading offers a very attractive concurrency model. Even if you have been burned in the past, threading remains a compelling option because you will likely have learned (the hard way) how to keep your code both simple and safe. I don’t have space to get into safer threaded programming here, but generally speaking, the best practice for using threads is to use the  `ThreadPoolExecutor`  class from the  `concurrent.futures`  module, passing all required data in through the  `submit()` method.  Example 2-1  shows a basic example. *Example 2-1. Best practice for threading* `from` ` ` `concurrent.futures` ` ` `import` ` ` `ThreadPoolExecutor` ` ` `as` ` ` `Executor` `def` ` ` `worker` `(` `data` `):` `    ` `<` `process` ` ` `the` ` ` `data` `>` **10 ** **| ** **Chapter 2: The Truth About Threads**
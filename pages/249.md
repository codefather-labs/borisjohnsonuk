Multi-Process Parallelism to be careful that two processes do not try and write to the same pipe at the same time. If you adapt the last example to work with a pipe, it will require changing the  pool.apply()  to  pool.apply_async() . This changes the execution of the next process to a non-blocking operation: cpython-book-samples 33 pool_pipe_celcius.py import  multiprocessing  as  mp def  to_celcius(child_pipe: mp.Pipe, parent_pipe: mp.Pipe): f  =  parent_pipe.recv() # time-consuming task ... c  =  (f  -  32 )  *  ( 5 / 9 ) child_pipe.send(c) if  __name__  ==  '__main__' : mp.set_start_method( 'spawn' ) pool_manager  =  mp.Manager() with  mp.Pool( 2 )  as  pool: parent_pipe, child_pipe  =  mp.Pipe() results  =  [] for  i  in  range( 110 ,  150 ,  10 ): parent_pipe.send(i) pool.apply_async(to_celcius, args = (child_pipe, parent_pipe)) print(child_pipe.recv()) parent_pipe.close() child_pipe.close() In this example, there is a risk of two or more processes trying to read from the parent pipe at the same time on the line: f  =  parent_pipe.recv() There is also a risk of two or more processes trying to write to the child pipe at the same time. 249
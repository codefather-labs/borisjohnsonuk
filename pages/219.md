Garbage Collection The Collection Stage In the main GC function,  collect()  targets a particular generation. There are 3 generations in CPython. Before you understand the purpose of the generations, it’s important to understand the collection algorithm. For each collection, the GC will use a doubly-linked list of type  PyGC_- HEAD . So that the GC doesn’t have to “ﬁnd” all container types, all container types that are a target for the GC have an additional header. This header links them all together in a doubly-linked list. When one of these container types is created, it adds itself to the list, and when it is destroyed, it removes itself. You can see an example of this in the  cellobject.c  type: Objects cellobject.c  line 7 PyObject * PyCell_New(PyObject *obj) { PyCellObject *op; op = (PyCellObject *)PyObject_GC_New(PyCellObject, &PyCell_Type); if  (op == NULL) return  NULL; op->ob_ref = obj; Py_XINCREF(obj); >> _PyObject_GC_TRACK(op); return  (PyObject *)op; } Because cells are mutable, the object is marked to be tracked by a call to  _PyObject_GC_TRACK() . When cell objects are deleted, the  cell_dealloc()  function is called. This function takes three steps: 219
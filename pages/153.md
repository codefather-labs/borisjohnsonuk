`  RETURN NEW;` `END;` `$$ LANGUAGE plpgsql;` `"""` `  ` `SQL_TABLE_UPDATE` ` ` `=` ` ` `"""` `\` `DROP TRIGGER IF EXISTS` `  ` `{table}` `_notify_update ON ` `{schema}` `.` `{table}` `;` `CREATE TRIGGER ` `{table}` `_notify_update` `  AFTER UPDATE ON ` `{schema}` `.` `{table}` `    FOR EACH ROW` `      EXECUTE PROCEDURE ` `{trigger_name}` `();` `"""` `  ` `SQL_TABLE_INSERT` ` ` `=` ` ` `"""` `\` `DROP TRIGGER IF EXISTS` `  ` `{table}` `_notify_insert ON ` `{schema}` `.` `{table}` `;` `CREATE TRIGGER ` `{table}` `_notify_insert` `  AFTER INSERT ON ` `{schema}` `.` `{table}` `    FOR EACH ROW` `      EXECUTE PROCEDURE ` `{trigger_name}` `();` `"""` `SQL_TABLE_DELETE` ` ` `=` ` ` `"""` `\` `DROP TRIGGER IF EXISTS` `  ` `{table}` `_notify_delete ON ` `{schema}` `.` `{table}` `;` `CREATE TRIGGER ` `{table}` `_notify_delete` `  AFTER DELETE ON ` `{schema}` `.` `{table}` `    FOR EACH ROW` `      EXECUTE PROCEDURE ` `{trigger_name}` `();` `"""` These functions require  `asyncpg` , although this import is used only to allow `Connection`  to be used in type annotations. The  `create_notify_trigger()`  coroutine function will create the trigger function itself in the database. The trigger function will contain the name of the channel that updates will be sent to. The code for the function itself is in the `SQL_CREATE_TRIGGER`  identifier, and it is set up as a format string. Recall from the case study example that update notifications included a “diff” section in which the difference between old and new data was shown. We use the `hstore`  feature of PostgreSQL to calculate that diff. It provides something close to the semantics of sets. The  `hstore`  extension is not enabled by default, so we enable it here. The desired trigger name and channel are substituted into the template and then executed. **142 ** **| ** **Appendix B: Supplementary Material**
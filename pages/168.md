Frame Execution my_trace()  that gets the stack from the current frame, prints the disassembled opcodes to the screen, and some extra information for debugging: cpython-book-samples 31 my_trace.py import  sys import  dis import  traceback import  io def  my_trace(frame, event, args): frame.f_trace_opcodes  =  True stack  =  traceback.extract_stack(frame) pad  =  " " * len(stack)  +  "|" if  event  ==  'opcode' : with  io.StringIO()  as  out: dis.disco(frame.f_code, frame.f_lasti, file = out) lines  =  out.getvalue().split( '\n' ) [print( f" { pad }{l} " )  for  l  in  lines] elif  event  ==  'call' : print( f" { pad } Calling  { frame . f_code } " ) elif  event  ==  'return' : print( f" { pad } Returning  { args } " ) elif  event  ==  'line' : print( f" { pad } Changing line to  { frame . f_lineno } " ) else : print( f" { pad }{ frame }  ( { event }  -  { args } )" ) print( f" { pad } ----------------------------------" ) return  my_trace sys.settrace(my_trace) # Run some code for a demo eval( '"-".join([letter for letter in "hello"])' ) The  sys.settrace()  function will set the current thread state default tracing function to the one provided. Any new frames created after this call will have  f_trace  set to this function. 168
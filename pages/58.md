`@asynccontextmanager` , also exists and makes it much easier to create simple async context managers. #### The contextlib Way
 This approach is analogous to the  `@contextmanager`  decorator in the  `contextlib` standard library. To recap,  Example 3-21  takes a look at the blocking way first. *Example 3-21. * *The* * blocking way* `from` ` ` `contextlib` ` ` `import` ` ` `contextmanager` `@contextmanager` `  ` `def` ` ` `web_page` `(` `url` `):` `    ` `data` ` ` `=` ` ` `download_webpage` `(` `url` `)` `  ` `    ` `yield` ` ` `data` `    ` `update_stats` `(` `url` `)` `  ` `with` ` ` `web_page` `(` `'google.com'` `)` ` ` `as` ` ` `data` `:` `  ` `    ` `process` `(` `data` `)` `  ` The  `@contextmanager`  decorator transforms a generator function into a context manager. This function call (which I made up for this example) looks suspiciously like the sort of thing that will want to use a network interface, which is many orders of magnitude slower than “normal” CPU-bound code. This context manager  *must* be used in a dedicated thread; otherwise, the whole program will be paused while waiting for data. Imagine that we update some statistics every time we process data from a URL, such as the number of times the URL has been downloaded. From a concurrency perspective, we would need to know whether this function involves I/O internally, such as writing to a database over a network. If so,  `update_stats()`  is also a blocking call. Our context manager is being used. Note specifically how the network call (to `download_webpage()` ) is hidden inside the construction of the context manager. This function call,  `process()` , might also be blocking. We’d have to look at what the function does, because the distinction between what is blocking or nonblocking is not clear-cut. It might be: •  Innocuous and nonblocking (fast and CPU-bound) **Async Context Managers: async with ** **| ** **47**
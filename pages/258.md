Multithreading bytecode operation has completed in a frame, this flag is checked, and the GIL is temporarily released and then reacquired: if  (_Py_atomic_load_relaxed(&ceval->gil_drop_request)) { /* Give another thread a chance */ if  (_PyThreadState_Swap(&runtime->gilstate, NULL) != tstate) { Py_FatalError( "ceval: tstate mix-up" ); } drop_gil(ceval, tstate); /* Other threads may run now */ take_gil(ceval, tstate); /* Check if we should make a quick exit. */ exit_thread_if_finalizing(tstate); if  (_PyThreadState_Swap(&runtime->gilstate, tstate) != NULL) { Py_FatalError( "ceval: orphan tstate" ); } } ... Despite the limitations that the GIL enforces on parallel execution, it means that multithreading in Python is very safe and ideal for running IO-bound tasks concurrently. 
##Related Source Files 

 Source ﬁles related to threading are: File Purpose Include pythread.h PyThread API and deﬁnition Lib threading.py High Level threading API and Standard Library module Modules _threadmodule.c  | Low Level thread API and Standard Library module Python thread.c C extension for the  thread  module Python thread_nt.h  | Windows Threading API Python thread_pthread.h  | POSIX Threading API 258
Reference Counting y  =  "hello" def  greet(message = y): print(message.capitalize()  +  " "  +  y) messages  =  [y] greet( * messages) At a glance,  y  is immediately referenced by: 1.  y  is a variable in the top-level scope 2.  y  is referenced as a default value for the keyword argument  message 3.  y  is referenced inside the  greet()  function 4.  y  is an item in the  messages  list Run this code with an additional snippet: import  sys print(sys.getrefcount(y)) The total references to  y  is 6. Instead of the logic for incrementing and decrementing references sitting within a central function that has to cater for all these cases (and more!), the logic is split into small parts. A bytecode operation should have a determining impact on the reference counter for the objects that it takes as arguments. For example, in the frame evaluation loop, the  LOAD_FAST  operation loads the object with a given name and pushes it to the top of the value stack. Once the variable name, which is provided in the  oparg , has been resolved using  GETLOCAL()  the reference counter is incremented: case  TARGET(LOAD_FAST): { PyObject *value = GETLOCAL(oparg); 211
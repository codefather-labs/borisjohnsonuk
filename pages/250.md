Multi-Process Parallelism child_pipe.send(c) If this situation occurs, data would be corrupted in either the receive or send operations: Parent Process Worker Pool Worker 0 Worker 1 [110, 120, 130, 140] Parent Pipe Child Pipe send() 010101010100011100 100101111011 recv() send() (Busy) (Busy) send() To avoid this, you can implement a semaphore lock on the Operating System. Then all child processes will check with the Lock before reading or writing to the same pipe. There are two locks required, one on the receiving end of the parent pipe, and another on the sending end of the child pipe: cpython-book-samples 33 pool_pipe_locks_celcius.py import  multiprocessing  as  mp def  to_celcius(child_pipe: mp.Pipe, parent_pipe: mp.Pipe, child_write_lock: mp.Lock, parent_read_lock: mp.Lock): parent_read_lock.acquire() try : f  =  parent_pipe.recv() finally : parent_read_lock.release() # time-consuming task ... c  =  (f  -  32 )  *  ( 5 / 9 ) child_write_lock.acquire() try : child_pipe.send(c) 250
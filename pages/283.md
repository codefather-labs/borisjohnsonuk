Subinterpreters the overhead to start a new process is signiﬁcant. Threading and async have small overhead but don’t oﬀer truly parallel execution because of the thread-safety guarantees in the GIL. The fourth option is  subinterpreters , which have a smaller overhead than  multiprocessing , and allow a GIL per subinterpreter. After all, it is the Global  Interpreter  Lock. Within the CPython runtime, there is always 1 interpreter. The interpreter holds the interpreter state, and within an interpreter, you can have 1 or many Python threads. The interpreter is the container for the evaluation loop. the interpreter also manages its own memory, reference counter, and garbage collection. CPython has low-level C APIs for creating interpreters, like the  Py_NewInterpreter() . Interpreter State Runtime Interpreter 0 (primary) Runtime State Heap CPython Runtime Files Locks Sockets Compiled Modules Instructions GIL Thread 0 (Primary) Threads 1-n Interpreter State Interpreter n Heap CPython Runtime Files Locks Sockets Compiled Modules Instructions GIL Thread 0 (Primary) Threads 1-n Note The subinterpreters module is still experimental in 3.9.0b1, so the API is subject to change and the implementation is still buggy. Because Interpreter state contains the memory allocation arena, a collection of all pointers to Python objects (local and global), subinterpreters cannot access the global variables of other interpreters. Simi- 283
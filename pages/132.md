`    ` `async` ` ` `def` ` ` `delete` `(` `self` `,` ` ` `request` `,` ` ` `id` `):` `        ` `ok` ` ` `=` ` ` `await` ` ` `model` `.` `delete_patron` `(` `app` `.` `pool` `,` ` ` `id` `)` `        ` `return` ` ` `json` `(` `dict` `(` `msg` `=` `'ok'` ` ` `if` ` ` `ok` ` ` `else` ` ` `'bad'` `))` `@app` `.` `listener` `(` `'before_server_start'` `)` `  ` `async` ` ` `def` ` ` `db_connect` `(` `app` `,` ` ` `loop` `):` `    ` `app` `.` `db` ` ` `=` ` ` `Database` `(` `'restaurant'` `,` ` ` `owner` `=` `False` `)` `  ` `    ` `app` `.` `pool` ` ` `=` ` ` `await` ` ` `app` `.` `db` `.` `connect` `()` `  ` `    ` `await` ` ` `model` `.` `create_table_if_missing` `(` `app` `.` `pool` `)` `  ` `    ` `await` ` ` `app` `.` `db` `.` `add_listener` `(` `'chan_patron'` `,` ` ` `model` `.` `db_event` `)` `  ` `@app` `.` `listener` `(` `'after_server_stop'` `)` `  ` `async` ` ` `def` ` ` `db_disconnect` `(` `app` `,` ` ` `loop` `):` `    ` `await` ` ` `app` `.` `db` `.` `disconnect` `()` `if` ` ` `__name__` ` ` `==` ` ` `"__main__"` `:` `    ` `parser` ` ` `=` ` ` `argparse` `.` `ArgumentParser` `()` `    ` `parser` `.` `add_argument` `(` `'--port'` `,` ` ` `type` `=` `int` `,` ` ` `default` `=` `8000` `)` `    ` `args` ` ` `=` ` ` `parser` `.` `parse_args` `()` `    ` `app` `.` `add_route` `(` `        ` `new_patron` `,` ` ` `'/patron'` `,` ` ` `methods` `=` `[` `'POST'` `])` `  ` `    ` `app` `.` `add_route` `(` `        ` `PatronAPI` `.` `as_view` `(),` ` ` `'/patron/<id:int>'` `)` `  ` `    ` `app` `.` `run` `(` `host` `=` `"0.0.0.0"` `,` ` ` `port` `=` `args` `.` `port` `)` The  `Database`  utility helper, as described earlier. This will provide the methods required to connect to the database. Two more tools I’ve cobbled together to log the elapsed time of each API endpoint. I used this in the previous discussion to detect when a  `GET`  was being returned from the cache. The implementations for  `aelapsed()`  and  `aprofiler()` are not important for this case study, but you can obtain them in  Example B-1 . We create the main Sanic app instance. This coroutine function is for creating new patron entries. In an  `add_route()` call toward the bottom of the code,  `new_patron()`  is associated with the endpoint  `/patron` , only for the  `POST`  HTTP method. The  `@aelapsed`  decorator is not part of the Sanic API: it’s my own invention, merely to log out timings for each call. Sanic provides immediate deserialization of received JSON data by using the  `.json`  attribute on the  `request`  object. The  `model`  module, which I imported, is the  *model*  for our  `patron`  table in the database. I’ll go through that in more detail in the next code listing; for now, just understand that all the database queries and SQL are in this  `model`  module. Here **asyncpg and Sanic ** **| ** **121**
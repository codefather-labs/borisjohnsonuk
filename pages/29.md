
![page_29_0](images/page_29_0.png)
 `def` ` ` `change` `(` `self` `,` ` ` `knives` `,` ` ` `forks` `):` `    ` `self` `.` `knives` ` ` `+=` ` ` `knives` `    ` `self` `.` `forks` ` ` `+=` ` ` `forks` The inline summation,  `+=` , is implemented internally (inside the C code for the Python interpreter itself) as a few separate steps: 1.  Read the current value,  `self.knives` , into a temporary location. 2.  Add the new value,  `knives` , to the value in that temporary location. 3.  Copy the new total from the temporary location back into the original location. The problem with preemptive multitasking is that any thread busy with these steps can be interrupted  *at any time* , and a different thread can be given the opportunity to work through the same steps. In this case, suppose ThreadBot  *A*  does step 1, and then the OS scheduler pauses  *A* and switches to ThreadBot  *B* .  *B*   *also*  reads the current value of  `self.knives` ; then execution goes back to  *A* .  *A*  increments its total and writes it back—but then  *B*  continues from where it got paused (after step 1), and it increments and writes back  *its* new total, thereby  *erasing*  the change made by  *A* ! While this may sound complex, this example of a race condition is just about the simplest possible case. We were able to check  *all*  the code, and we even have tests that can reproduce the problem on demand. In the real world, in large projects, try to imagine how much more difficult it can become! This problem can be fixed by placing a  *lock*  around the modification of the shared state (imagine we added a  `threading.Lock`  to the  `Cutlery`  class): `def` ` ` `change` `(` `self` `,` ` ` `knives` `,` ` ` `forks` `):` `    ` `with` ` ` `self` `.` `lock` `:` `      ` `self` `.` `knives` ` ` `+=` ` ` `knives` `      ` `self` `.` `forks` ` ` `+=` ` ` `forks` But this requires you to know all the places where state will be shared between multiple threads. This approach is viable when you control all the source code, but it becomes very difficult when many third-party libraries are used—which is likely in Python thanks to the wonderful open source ecosystem. Note that it was not possible to see the race condition by looking at the source code alone. This is because the source code provides no hints about where execution is going to switch between threads. That wouldn’t be useful anyway, because the OS can switch between threads just about anywhere. **18 ** **| ** **Chapter 2: The Truth About Threads**
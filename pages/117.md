`            ` `while` ` ` `data` ` ` `:` `=` ` ` `await` ` ` `queue` `.` `get` `():` `  ` `                ` `print` `(` `'sending data:'` `,` ` ` `data` `)` `                ` `resp` `.` `send` `(` `json` `.` `dumps` `(` `data` `))` `  ` `    ` `return` ` ` `resp` `async` ` ` `def` ` ` `index` `(` `request` `):` `  ` `    ` `return` ` ` `aiohttp` `.` `web` `.` `FileResponse` `(` `'./charts.html'` `)` `async` ` ` `def` ` ` `start_collector` `(` `app` `):` `  ` `    ` `app` `[` `'collector'` `]` ` ` `=` ` ` `app` `.` `loop` `.` `create_task` `(` `collector` `())` `async` ` ` `def` ` ` `stop_collector` `(` `app` `):` `    ` `print` `(` `'Stopping collector...'` `)` `    ` `app` `[` `'collector'` `]` `.` `cancel` `()` `  ` `    ` `await` ` ` `app` `[` `'collector'` `]` `    ` `ctx` `.` `term` `()` `if` ` ` `__name__` ` ` `==` ` ` `'__main__'` `:` `    ` `app` ` ` `=` ` ` `web` `.` `Application` `()` `    ` `app` `.` `router` `.` `add_route` `(` `'GET'` `,` ` ` `'/'` `,` ` ` `index` `)` `    ` `app` `.` `router` `.` `add_route` `(` `'GET'` `,` ` ` `'/feed'` `,` ` ` `feed` `)` `    ` `app` `.` `on_startup` `.` `append` `(` `start_collector` `)` `  ` `    ` `app` `.` `on_cleanup` `.` `append` `(` `stop_collector` `)` `    ` `web` `.` `run_app` `(` `app` `,` ` ` `host` `=` `'127.0.0.1'` `,` ` ` `port` `=` `8088` `)` One half of this program will receive data from other applications, and the other half will provide data to browser clients via  *server-sent events*  (SSEs). I use a `WeakSet()`  to keep track of all the currently connected web clients. Each connected client will have an associated  `Queue()`  instance, so this  `connections`  identifier is really a set of queues. Recall that in the application layer, I used a  `zmq.PUB`  socket; here in the collection layer, I use its partner, the  `zmq.SUB`  socket type. This ØMQ socket can only receive, not send. For the  `zmq.SUB`  socket type, providing a subscription name is required, but for our purposes, we’ll just take everything that comes in—hence the empty topic name. I  *bind*  the  `zmq.SUB`  socket. Think about that for second. In pub-sub configurations, you usually have to make the  *pub*  end the server ( `bind()` ) and the  *sub*  end the client ( `connect()` ). ØMQ is different: either end can be the server. For our use case, this is important, because each of our application-layer instances will be connecting to the same collection server domain name, and not the other way around. **106 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
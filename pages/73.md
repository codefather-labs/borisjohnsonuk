2.  If that future raises an exception, the exception will  *also*  be raised out of `run_until_complete()` , which means that the loop will stop. 3.  If  `run_until_complete()`  is being used on a group future, any exception raised inside  *any of the subtasks*  will also be raised in the “group” future if it isn’t handled in the subtask. Note this includes  `CancelledError` . 4.  If only some tasks handle  `CancelledError`  and others don’t, the ones that don’t will cause the loop to stop. This means that the loop will be stopped  *before*  all the tasks are done. 5.  For  shutdown,  we  really  don’t  want  this  behavior.  We  want `run_until_complete()`  to finish only when all the tasks in the group have finished, regardless of whether some of the tasks raise exceptions. 6.  Hence we have  `gather(*, return_exceptions=True)` : that setting makes the “group” future treat exceptions from the subtasks as  *returned values* , so that they don’t bubble out and interfere with  `run_until_complete()` . And there you have it: the relationship between  `return_exceptions=True`  and `run_until_complete()` . An undesirable consequence of capturing exceptions in this way is that some errors may escape your attention because they’re now (effectively) being handled inside the group task. If this is a concern, you can obtain the output list from  `run_until_complete()`  and scan it for any subclasses of  `Exception` , and then write log messages appropriate for your situation.  Example 3-32  demonstrates this approach. *Example 3-32. All the tasks will complete* `# alltaskscomplete.py` `import` ` ` `asyncio` `async` ` ` `def` ` ` `f` `(` `delay` `):` `    ` `await` ` ` `asyncio` `.` `sleep` `(` `1` ` ` `/` ` ` `delay` `)` `  ` `    ` `return` ` ` `delay` `loop` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` `for` ` ` `i` ` ` `in` ` ` `range` `(` `10` `):` `    ` `loop` `.` `create_task` `(` `f` `(` `i` `))` `pending` ` ` `=` ` ` `asyncio` `.` `all_tasks` `()` `group` ` ` `=` ` ` `asyncio` `.` `gather` `(` `*` `pending` `,` ` ` `return_exceptions` `=` `True` `)` `results` ` ` `=` ` ` `loop` `.` `run_until_complete` `(` `group` `)` `print` `(` `f` `'Results: ` `{results}` `'` `)` `loop` `.` `close` `()` It would be awful if someone were to pass in a zero… Here’s the output: **62 ** **| ** **Chapter 3: Asyncio Walk-Through**
Using Timeit for Micro-Benchmarks 
##Example 

 In this book, you have introduced changes to the  float  type by supporting the almost-equal operator. Try this test to see the current performance of comparing two float values: $ ./python -m timeit -n 1000 "x=1.0001; y=1.0000; x~=y" 1000 loops, best of 5: 177 nsec per loop The implementation of this comparison is in  float_richcompare() , inside  Objects floatobject.c : Objects floatobject.c  line 358 static  PyObject* float_richcompare(PyObject *v, PyObject *w,  int  op) { ... case  Py_AlE: { double  diff = fabs(i - j); double  rel_tol =  1e-9 ; double  abs_tol =  0.1 ; r = (((diff <= fabs(rel_tol * j)) || (diff <= fabs(rel_tol * i))) || (diff <= abs_tol)); } break ; } Notice that the  rel_tol  and  abs_tol  values are constant, but havenâ€™t been marked as constant. Change them to: const double  rel_tol =  1e-9 ; const double  abs_tol =  0.1 ; Now, compile CPython again and re-run the test: 355
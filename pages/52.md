7  The documentation is inconsistent here: the signature is given as  `AbstractEventLoop.run_until_com` `plete` ( `future` ), but it really should be  `AbstractEventLoop.run_until_complete` ( `coro_or_future` ) as the same rules apply. `>>>` ` ` `print` `(` `fut` `.` `result` `())` `  ` `I` ` ` `have` ` ` `finished` `.` Create a simple  `main`  function. We can run this, wait for a bit, and then set a result on this  `Future` ,  `f` . Set the result. Manually create a  `Future`  instance. Note that this instance is (by default) tied to our  `loop` , but it is not and will not be attached to any coroutine (that’s what  `Task` s are for). Before doing anything, verify that the future is not done yet. *Schedule*  the  `main()`  coroutine, passing the future. Remember, all the  `main()` coroutine does is sleep and then toggle the  `Future`  instance. (Note that the `main()`  coroutine will not start running yet: coroutines run only when the loop is running.) Here we use  `run_until_complete()`  on a  `Future`  instance, rather than a  `Task` instance. 7  This is different from what you’ve seen before. Now that the loop is running, the  `main()`  coroutine will begin executing. Eventually, the future completes when its result is set. After completion, the result can be accessed. Of course, it is unlikely that you will work with  `Future`  directly in the way shown here; the code sample is for education purposes only. Most of your contact with  `asyn` `cio`  will be through  `Task`  instances. You might wonder what happens if you call  `set_result()`  on a  `Task`  instance. It was possible to do this before Python 3.8, but it is no longer allowed.  `Task`  instances are wrappers for coroutine objects, and their result values can be set only internally as the result of the underlying coroutine function, as shown in  Example 3-17 . *Example 3-17. Calling set_result() on a Task* `>>>` ` ` `import` ` ` `asyncio` `>>>` ` ` `from` ` ` `contextlib` ` ` `import` ` ` `suppress` **Tasks and Futures ** **| ** **41**
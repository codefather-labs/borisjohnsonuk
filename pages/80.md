
![page_80_0](images/page_80_0.png)
 `    ` `time` `.` `sleep` `(` `1.5` `)` `  ` `    ` `print` `(` `f` `"{time.ctime()} Hello from a thread!"` `)` `asyncio` `.` `run` `(` `main` `())` This code sample is exactly the same as the one in  Example 3-3 ,  *except*  that the sleep time in the blocking function is now longer than in the async one. Running this code produces the following output: `$ python quickstart.py` `Fri Jan 24 16:25:08 2020 Hello!` `Fri Jan 24 16:25:09 2020 Goodbye!` `exception calling callback for <Future at [...snip...]>` `Traceback (most recent call last):` `<big nasty traceback>` `RuntimeError: Event loop is closed` `Fri Jan 24 16:25:09 2020 Hello from a thread!` What’s happening here is that behind the scenes,  `run_in_executor()`  does  *not*  create a  `Task`  instance: it returns a  `Future` . That means it isn’t included in the set of “active tasks” that get cancelled inside  `asyncio.run()` , and therefore  `run_until_complete()` (called inside  `asyncio.run()` ) does  *not*  wait for the executor task to finish. The `RuntimeError`  is being raised from the internal  `loop.close()`  call made inside  `asyn` `cio.run()` . At the time of writing,  `loop.close()`  in Python 3.8 does not wait for all executor jobs to finish, and this is why the  `Future`  returned from  `run_in_executor()`  complains: by the time it resolves, the loop has already been closed. There are discussions about how to improve this in the core Python dev team, but until a solution has been settled on, you’re going to need a strategy for handling these errors. In Python 3.9, the  `asyncio.run()`  function  has been improved  to correctly wait for executor shutdown, but at the time of writing, this has not yet been backported to Python 3.8. Several ideas for fixing this spring to mind, all with different trade-offs, and we’re going to look at a few of them. My real goal for this exercise is to help you think about the event loop life cycle from different points of view, considering the lifetime management of all the coroutines, threads, and subprocesses that might be interoperating in a nontrivial program. The first idea—and the easiest to implement, as shown in  Example 3-37 — is to always `await`  an executor task from inside a coroutine. **Starting Up and Shutting Down (Gracefully!) ** **| ** **69**
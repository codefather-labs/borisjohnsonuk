Of course, it should go without saying that you should never actually do this! If your coroutine receives a cancellation signal, that is a clear directive to do only whatever cleanup is necessary and exit. Don’t just ignore it. By this point, it’s getting pretty tiring  *pretending*  to be an event loop by manually doing all the  `.send(None)`  calls, so in  Example 3-11  we’ll bring in the loop provided by  `asyncio`  and clean up the preceding example accordingly. *Example 3-11. Using the event loop to execute coroutines* `>>>` ` ` `async` ` ` `def` ` ` `f` `():` `...` `     ` `await` ` ` `asyncio` `.` `sleep` `(` `0` `)` `...` `     ` `return` ` ` `111` `>>>` ` ` `loop` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` `  ` `>>>` ` ` `coro` ` ` `=` ` ` `f` `()` `>>>` ` ` `loop` `.` `run_until_complete` `(` `coro` `)` `  ` `111` Obtain a loop. Run the coroutine to completion. Internally, this is doing all those  `.send(None)` method calls for us, and it detects completion of our coroutine with the `StopIteration`  exception, which also contains our return value. ### Event Loop
 The preceding section showed how the  `send()`  and  `throw()`  methods can interact with a coroutine, but that was just to help you understand how coroutines themselves are structured. The event loop in  `asyncio`  handles all of the switching between coroutines, as well as catching those  `StopIteration`  exceptions—and much more, such as listening to sockets and file descriptors for events. You can get by without ever needing to work with the event loop directly: your  `asyn` `cio`  code can be written entirely using  `await`  calls, initiated by an  `asyncio.run(` `coro` `)` call. However, at times some degree of interaction with the event loop itself might be necessary, and here we’ll discuss how to obtain it. There are two ways: *Recommended* `asyncio.get_running_loop()` , callable from inside the context of a coroutine *Discouraged* `asyncio.get_event_loop()` , callable from anywhere **Event Loop ** **| ** **37**
I’m using the  `asyncio`  support in  `pyzmq` , which means that all  `send()`  and  `recv()` calls must use the  `await`  keyword. The  `Poller`  no longer appears anywhere, because it’s been integrated into the  `asyncio`  event loop itself. This is the handler for the  `SUB`  socket. The structure is very similar to the  `PULL` socket’s handler, but that need not have been the case. If more complex logic had been required, I’d have been able to easily add it here, fully encapsulated within the  `SUB` -handler code only. Again, the  `asyncio` -compatible sockets require the  `await`  keyword to send and receive. The output is the same as before, so I won’t show it. The use of coroutines has, in my opinion, a staggeringly positive effect on the code layout in these examples. In real production code with lots of ØMQ sockets, the coroutine handlers for each could even be in separate files, providing more opportunities for better code structure. And even for programs with a single read/write socket, it is very easy to use separate coroutines for reading and writing, if necessary. The improved code looks a lot like threaded code, and indeed, for the specific example shown here, the same refactor will work for threading: run blocking `do_receiver()`  and  `do_subscriber()`  functions in separate threads. But do you really want to deal with even the  *potential*  for race conditions, especially as your application grows in features and complexity over time? There is lots to explore here, and as I said before, these magic sockets are a lot of fun to play with. In the next case study, we’ll look at a more practical use of ØMQ. #### Case Study: Application Performance Monitoring
 With the modern, containerized, microservice-based deployment practices of today, some things that used to be trivial, such as monitoring your apps’ CPU and memory usage, have become somewhat more complicated than just running  `top` . Several commercial products have emerged over the last few years to deal with these problems, but their cost can be prohibitive for small startup teams and hobbyists. In this case study, I’ll exploit ØMQ and  `asyncio`  to build a toy prototype for distributed application monitoring. Our design has three parts: *Application layer* This layer contains all our applications. Examples might be a “customers” microservice, a “bookings” microservice, an “emailer” microservice, and so on. I will add a ØMQ “transmitting” socket to each of our applications. This socket will send performance metrics to a central server. **102 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
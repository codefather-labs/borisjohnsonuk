Symbol Tables switch  (s->kind) { case  FunctionDef_kind: if  (!symtable_add_def(st, s->v.FunctionDef.name, DEF_LOCAL)) VISIT_QUIT(st,  0 ); if  (s->v.FunctionDef.args->defaults) VISIT_SEQ(st, expr, s->v.FunctionDef.args->defaults); if  (s->v.FunctionDef.args->kw_defaults) VISIT_SEQ_WITH_NULL(st, expr, s->v.FunctionDef.args->kw_defaults); if  (!symtable_visit_annotations(st, s, s->v.FunctionDef.args, s->v.FunctionDef.returns)) VISIT_QUIT(st,  0 ); if  (s->v.FunctionDef.decorator_list) VISIT_SEQ(st, expr, s->v.FunctionDef.decorator_list); if  (!symtable_enter_block(st, s->v.FunctionDef.name, FunctionBlock, ( void  *)s, s->lineno, s->col_offset)) VISIT_QUIT(st,  0 ); VISIT(st, arguments, s->v.FunctionDef.args); VISIT_SEQ(st, stmt, s->v.FunctionDef.body); if  (!symtable_exit_block(st, s)) VISIT_QUIT(st,  0 ); break ; case  ClassDef_kind: { ... } case  Return_kind: ... case  Delete_kind: ... case  Assign_kind: ... case  AnnAssign_kind: ... Once the resulting symbol table has been created, it is passed on to the compiler. 131
Reference Counting case  TARGET(BINARY_MULTIPLY): { PyObject *right = POP(); PyObject *left = TOP(); PyObject *res = PyNumber_Multiply(left, right); >>> Py_DECREF(left); >>> Py_DECREF(right); SET_TOP(res); if  (res == NULL) goto  error; DISPATCH(); } The resulting number,  res , will have a reference count of 1 before it is set as the top of the value stack. 
##Conclusion 

 CPython’s reference counter has the beneﬁts of being simple, fast, and eﬃcient. The biggest drawback of the reference counter is that it needs to cater for, and carefully balance, the eﬀect of every operation. As you just saw, a bytecode operation increments the counter, and it is assumed that an equivalent operation will decrement it properly. What happens if there’s an unexpected error? Have all possible scenarios been tested? Everything discussed so far is within the realm of the CPython runtime. The Python developer has little to no control over this behavior. There is also a signiﬁcant flaw in the reference counting approach– cyclical references . Take this Python example: x  =  [] x.append(x) del  x 213
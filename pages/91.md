So that’s our server; now we need clients, and then we can show some output. For demonstration purposes, I’ll make two kinds of clients: a  *sender*  and a  *listener* . The server doesn’t differentiate; all clients are the same. The distinction between sender and listener behavior is only for educational purposes.  Example 4-3  shows the code for the listener application. *Example 4-3. Listener: a toolkit for listening for messages on our message broker* `# mq_client_listen.py` `import` ` ` `asyncio` `import` ` ` `argparse` `,` ` ` `uuid` `from` ` ` `msgproto` ` ` `import` ` ` `read_msg` `,` ` ` `send_msg` `async` ` ` `def` ` ` `main` `(` `args` `):` `  ` `me` ` ` `=` ` ` `uuid` `.` `uuid4` `()` `.` `hex` `[:` `8` `]` ` ` `  ` `print` `(` `f` `'Starting up ` `{me}` `'` `)` `  ` `reader` `,` ` ` `writer` ` ` `=` ` ` `await` ` ` `asyncio` `.` `open_connection` `(` `    ` `args` `.` `host` `,` ` ` `args` `.` `port` `)` ` ` `  ` `print` `(` `f` `'I am {writer.get_extra_info("sockname")}'` `)` `  ` `channel` ` ` `=` ` ` `args` `.` `listen` `.` `encode` `()` `  ` `  ` `await` ` ` `send_msg` `(` `writer` `,` ` ` `channel` `)` `  ` `  ` `try` `:` `    ` `while` ` ` `data` ` ` `:` `=` ` ` `await` ` ` `read_msg` `(` `reader` `):` `  ` `      ` `print` `(` `f` `'Received by ` `{me}` `: ` `{data[:20]}` `'` `)` `    ` `print` `(` `'Connection ended.'` `)` `  ` `except` ` ` `asyncio` `.` `IncompleteReadError` `:` `    ` `print` `(` `'Server closed.'` `)` `  ` `finally` `:` `    ` `writer` `.` `close` `()` `    ` `await` ` ` `writer` `.` `wait_closed` `()` `if` ` ` `__name__` ` ` `==` ` ` `'__main__'` `:` `  ` `parser` ` ` `=` ` ` `argparse` `.` `ArgumentParser` `()` ` ` `  ` `parser` `.` `add_argument` `(` `'--host'` `,` ` ` `default` `=` `'localhost'` `)` `  ` `parser` `.` `add_argument` `(` `'--port'` `,` ` ` `default` `=` `25000` `)` `  ` `parser` `.` `add_argument` `(` `'--listen'` `,` ` ` `default` `=` `'/topic/foo'` `)` `  ` `try` `:` `    ` `asyncio` `.` `run` `(` `main` `(` `parser` `.` `parse_args` `()))` `  ` `except` ` ` `KeyboardInterrupt` `:` `    ` `print` `(` `'Bye!'` `)` The  `uuid`  standard library module is a convenient way of creating an “identity” for this listener. If you start up multiple instances, each will have its own identity, and you’ll be able to track what is happening in the logs. Open a connection to the server. **80 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**

![page_36_0](images/page_36_0.png)
 `group`  =  `asyncio.gather(task1, task2, task3)` When the “main” part of the program unblocks, either due to a  process signal being received or the loop being stopped by some code calling  `loop.stop()` , the code after  `run_until_complete()`  will run. The standard idiom as shown here is to gather the still-pending tasks, cancel them, and then use  `loop.run_until_com` `plete()`  again until those tasks are done.  `gather()`  is the method for doing the gathering. Note that  `asyncio.run()`  will do all of the cancelling, gathering, and waiting for pending tasks to finish up. `loop.close()` `loop.close()`  is usually the final action: it must be called on a stopped loop, and it will clear all queues and shut down the executor. A  *stopped*  loop can be restarted, but a  *closed*  loop is gone for good. Internally,  `asyncio.run()`  will close the loop before returning. This is fine because  `run()`  creates a new event loop every time you call it. Example 3-1  shows that if you use  `asyncio.run()` , none of these steps are necessary: they are all done for you. However, it is important to understand these steps because more complex situations will come up in practice, and you’ll need the extra knowledge to deal with them. Several of these are covered in detail later in the book. The preceding example is still too simplistic to be useful in a practical setting. More information around correct shutdown handling is required. The goal of the example is merely to introduce the most important functions and methods in  `asyncio` . More practical information for shutdown handling is presented in  “Starting Up and Shutting Down (Gracefully!)” on page 57 . `asyncio`  in Python exposes a great deal of the underlying machinery around the event loop—and requires you to be aware of aspects like lifecycle management. This is different from Node.js, for example, which also contains an event loop but keeps it somewhat hidden away. However, once you’ve worked with  `asyncio`  for bit, you’ll begin to notice that the pattern for starting up and shutting down the event loop doesn’t stray terribly far from the code presented here. We’ll examine some of the nuances of managing the loop life cycle in more detail later in the book. I left something out in the preceding example. The last item of basic functionality you’ll need to know about is how to run  *blocking*  functions. The thing about cooperative multitasking is that you need all I/O-bound functions to…well, cooperate, and that means allowing a context switch back to the loop using the keyword `await` . Most of the Python code available in the wild today does not do this, and instead relies on you to run such functions in threads. Until there is more widespread **Quickstart ** **| ** **25**
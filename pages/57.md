
![page_57_0](images/page_57_0.png)
 In the next few sections, we’ll go back to language-level features, starting with asynchronous context managers. ### Async Context Managers: async with
 Support for coroutines in context managers turns out to be exceptionally convenient. This makes sense, because many situations require network resources—say, connections—to be opened and closed within a well-defined scope. The key to understanding  `async with`  is to realize that the operation of a context manager is driven by  *method calls* , and then consider: what if those methods were coroutine functions? Indeed, this is exactly how it works, as shown in  Example 3-20 . *Example 3-20. Async context manager* `class` ` ` `Connection` `:` `    ` `def` ` ` `__init__` `(` `self` `,` ` ` `host` `,` ` ` `port` `):` `        ` `self` `.` `host` ` ` `=` ` ` `host` `        ` `self` `.` `port` ` ` `=` ` ` `port` `    ` `async` ` ` `def` ` ` `__aenter__` `(` `self` `):` `  ` `        ` `self` `.` `conn` ` ` `=` ` ` `await` ` ` `get_conn` `(` `self` `.` `host` `,` ` ` `self` `.` `port` `)` `        ` `return` ` ` `conn` `    ` `async` ` ` `def` ` ` `__aexit__` `(` `self` `,` ` ` `exc_type` `,` ` ` `exc` `,` ` ` `tb` `):` `  ` `        ` `await` ` ` `self` `.` `conn` `.` `close` `()` `async` ` ` `with` ` ` `Connection` `(` `'localhost'` `,` ` ` `9001` `)` ` ` `as` ` ` `conn` `:` `    ` `<` `do` ` ` `stuff` ` ` `with` ` ` `conn` `>` Instead of the  `__enter__()`  special method for synchronous context managers, the new  `__aenter__()`  special method is used. This special method must be an `async def`  method. Likewise, instead of  `__exit__()` , use  `__aexit__()` . The parameters are identical to those for  `__exit__()`  and are populated if an exception was raised in the body of the context manager. Just because you’re using  `asyncio`  in your program, that doesn’t mean that all your context managers must be async ones like these. They’re useful only if you need to  `await`  something inside the  *enter* and  *exit*  methods. If there is no blocking I/O code, just use regular context managers. Now—between you and me—I don’t much like using this explicit style of context manager when the wonderful  `@contextmanager`  decorator exists in the  `contextlib` module of the standard library. As you might guess, an asynchronous version, **46 ** **| ** **Chapter 3: Asyncio Walk-Through**
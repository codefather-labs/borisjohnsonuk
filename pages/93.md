Conclusion 
#Conclusion 

 In this chapter, you’ve uncovered how Python’s many conﬁguration options are loaded and how code is input into the interpreter. Python’s flexibility of input makes it a great tool for a range of applications, such as: • Command-line utilities • Long-running network applications, like web servers • Short, composable scripts Python’s ability to set conﬁguration properties in many ways causes complexity. For example, if you tested a Python application on Python 3.8, and it executed correctly. But in a diﬀerent environment, it failed, you need to understand what settings were diﬀerent in that environment. This means you’d need to inspect environment variables, runtime flags, and even the sys conﬁg properties. The compile-time properties found in sys conﬁg can be diﬀerent amongst distributions of Python. For example, Python 3.8 downloaded from python.org for macOS has diﬀerent default values than the Python 3.8 distribution found on Homebrew or the one found on the Anaconda distribution. All of these input methods have an output of a Python module. In the next chapter, you will uncover how modules are created from the input. Leave feedback on this section » 93
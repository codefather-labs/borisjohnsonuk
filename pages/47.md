coroutine from outside; i.e., by the event loop, which we’re still simulating with manual  `send()`  and  `throw()`  commands. In real code, which you’ll see later, `CancelledError`  is raised inside the task-wrapped coroutine when tasks are cancelled. A simple message to say that the task got cancelled. Note that by handling the exception, we ensure it will no longer propagate and our coroutine will  `return` . Here we  `throw()`  the  `CancelledError`  exception. As expected, we see our cancellation message being printed. Our coroutine exits normally. (Recall that the  `StopIteration`  exception is the normal way that coroutines exit.) Just to drive home the point about how task cancellation is nothing more than regular exception raising (and handling), let’s look at  Example 3-10 , where we absorb cancellation and move on to a different coroutine. *Example 3-10. For educational purposes only—don’t do this!* `>>>` ` ` `async` ` ` `def` ` ` `f` `():` `...` `     ` `try` `:` `...` `         ` `while` ` ` `True` `:` ` ` `await` ` ` `asyncio` `.` `sleep` `(` `0` `)` `...` `     ` `except` ` ` `asyncio` `.` `CancelledError` `:` `...` `         ` `print` `(` `'Nope!'` `)` `...` `         ` `while` ` ` `True` `:` ` ` `await` ` ` `asyncio` `.` `sleep` `(` `0` `)` ` ` `...` `     ` `else` `:` `...` `         ` `return` ` ` `111` `>>>` ` ` `coro` ` ` `=` ` ` `f` `()` `>>>` ` ` `coro` `.` `send` `(` `None` `)` `>>>` ` ` `coro` `.` `throw` `(` `asyncio` `.` `CancelledError` `)` `  ` `Nope` `!` `>>>` ` ` `coro` `.` `send` `(` `None` `)` `  ` Instead of printing a message, what happens if after cancellation, we just go right back to awaiting another awaitable? Unsurprisingly, our outer coroutine continues to live, and it immediately suspends again inside the  *new*  coroutine. Everything proceeds normally, and our coroutine continues to suspend and resume as expected. **36 ** **| ** **Chapter 3: Asyncio Walk-Through**
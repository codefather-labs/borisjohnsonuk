`    ` `for` ` ` `i` ` ` `in` ` ` `range` `():` `        ` `loop` `.` `create_task` `(` `<` `some` ` ` `other` ` ` `coro` `>` `)` In this example, the intention is to launch completely new tasks inside the coroutine. By not awaiting them, we ensure they will run independently of the execution context inside coroutine function  `f()` . In fact,  `f()`  will exit before the tasks that it launched have completed. Before Python 3.7, it was necessary to first obtain the  `loop`  instance to schedule a task, but with the introduction of  `get_running_loop()`  came other  `asyncio`  functions that use it, like  `asyncio.create_task()` . From Python 3.7 on, the code to spawn an async task now looks like  Example 3-14 . *Example 3-14. Creating tasks the modern way* `import` ` ` `asyncio` `async` ` ` `def` ` ` `f` `():` `    ` `# Create some tasks!` `    ` `for` ` ` `i` ` ` `in` ` ` `range` `():` `        ` `asyncio` `.` `create_task` `(` `<` `some` ` ` `other` ` ` `coro` `>` `)` It is also possible to use another low-level function called  `asyncio.ensure_future()` to spawn tasks in the same way as  `create_task()` , and you will likely still see calls to `ensure_future()`  in older  `asyncio`  code. I considered avoiding the distraction of discussing  `ensure_future()` , but it is a perfect case study of an  `asyncio`  API that was intended only for framework designers, but made the original adoption of  `asyncio` much more difficult to understand for application developers. The difference between  `asyncio.create_task()`  and  `asyncio.ensure_future()`  is subtle and confusing for many newcomers. We explore these differences in the next section. ### Tasks and Futures
 Earlier we covered coroutines, and how they need to be run on a loop to be useful. Now I want to talk briefly about the  `Task`  and  `Future`  APIs. The one you will work with the most is  `Task` , as most of your work will involve running coroutines with the `create_task()`  function, exactly as set out in  “Quickstart” on page 22 . The  `Future` class is actually a superclass of  `Task` , and it provides all of the functionality for interaction with the loop. A simple way to think of it is like this: a  `Future`  represents a future completion state of some activity and is managed by the loop. A  `Task`  is exactly the same, but the specific “activity” is a coroutine— probably one of yours that you created with an  `async` `def`  function plus  `create_task()` . **Tasks and Futures ** **| ** **39**
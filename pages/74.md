
![page_74_0](images/page_74_0.png)
 
![page_74_1](images/page_74_1.png)
 `$ ` `python alltaskscomplete.py` `Results: [6, 9, 3, 7, ...` `          ZeroDivisionError('division by zero',), 4, ...` `          8, 1, 5, 2]` Without  `return_exceptions=True` , the  `ZeroDivisionError`  would be raised from `run_until_complete()` , stopping the loop and thus preventing the other tasks from finishing. In the next section, we look at handling signals (beyond KeyboardInterrupt), but before we get there, it’s worth keeping in mind that graceful shutdown is one of the more difficult aspects of network programming, and this remains true for  `asyncio` . The information in this section is merely a start. I encourage you to have specific tests for clean shutdown in your own automated test suites. Different applications often require different strategies. I’ve published a tiny package on the Python package index (PyPI) called  `aiorun` , primarily for my own experiments and education in dealing with  `asyncio`  shutdown, that incorporates many ideas from this section. It may also be useful for you to tinker with the code and experiment with your own ideas around  `asyncio`  shutdown scenarios. #### Signals
 Previous examples showed how the event loop is stopped with a  `KeyboardInterrupt` ; i.e., pressing Ctrl-C. Internally within  `asyncio.run()` , the raised  `KeyboardInterrupt` effectively unblocks a  `loop.run_until_complete()`  call and allows the subsequent shutdown sequence to happen. `KeyboardInterrupt`  corresponds to the  `SIGINT`  signal. In network services, the more common signal for process termination is actually  `SIGTERM` , and this is also the default signal when you use the  `kill`  command in a Unix shell. The  `kill`  command on Unix systems is deceptively named: all it does it send signals to a process. Without arguments,  `kill`   `<PID>` will send a  `TERM`  signal: your process can receive the signal and do a graceful shutdown, or simply ignore it! That’s a bad idea, though, because if your process doesn’t stop eventually, the next thing the would-be killer usually does is  `kill -s KILL`   `<PID>` , which sends the  `KILL`  signal. This will shut you down, and there’s nothing your program can do about it. Receiving the  `TERM`  (or  `INT` ) signal is your opportunity to shut down in a controlled way. **Starting Up and Shutting Down (Gracefully!) ** **| ** **63**
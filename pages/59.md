•  Mildly blocking (fast and I/O-bound, perhaps something like fast disk access instead of network I/O) •  Blocking (slow and I/O-bound) •  Diabolical (slow and CPU-bound) For the sake of simplicity in this example, let’s presume that the call to  `process()` is a fast, CPU-bound operation and therefore nonblocking. Example 3-22  is exactly the same example, but using the new async-aware helper that was introduced in Python 3.7. *Example 3-22. * *The* * nonblocking way* `from` ` ` `contextlib` ` ` `import` ` ` `asynccontextmanager` `@asynccontextmanager` `  ` `async` ` ` `def` ` ` `web_page` `(` `url` `):` `  ` `    ` `data` ` ` `=` ` ` `await` ` ` `download_webpage` `(` `url` `)` `  ` `    ` `yield` ` ` `data` `  ` `    ` `await` ` ` `update_stats` `(` `url` `)` `  ` `async` ` ` `with` ` ` `web_page` `(` `'google.com'` `)` ` ` `as` ` ` `data` `:` `  ` `    ` `process` `(` `data` `)` The new  `@asynccontextmanager`  decorator is used in exactly the same way. It does, however, require that the decorated generator function be declared with `async def` . As before, we fetch the data from the URL before making it available to the body of the context manager. I have added the  `await`  keyword, which tells us that this coroutine will allow the event loop to run other tasks while we wait for the network call to complete. Note that we  *cannot*  simply tack on the  `await`  keyword to anything. This change presupposes that we were also able to  *modify*  the  `download_webpage()`  function itself, and convert it into a coroutine that is compatible with the  `await`  keyword. For the times when it is not possible to modify the function, a different approach is needed; we’ll discuss that in the next example. As before, the data is made available to the body of the context manager. I’m trying to keep the code simple, so I’ve omitted the usual  `try/finally`  handler that you should normally write to deal with exceptions raised in the body of caller. **48 ** **| ** **Chapter 3: Asyncio Walk-Through**
Our  `main()`  coroutine function simply waits for data on a queue. This line will suspend until there is data, exactly until there is data, exactly like calling  `get()`  on an  `asyncio.Queue`  instance. The queue object has two  *faces* : this one is called `async_q`  and provides the async-compatible queue API. Print a message. Inside the  `data_source()`  function, a random  `int`  is generated, which is used both as a sleep duration and a data value. Note that the  `time.sleep()`  call is blocking, so this function must be executed in a thread. Place the data onto the Janus queue. This shows the other  *face*  of the Janus queue: `sync_q` , which provides the standard, blocking  `Queue`  API. Here’s the output: `$ ` `<name>` `Got 2 off queue` `Got 4 off queue` `Got 4 off queue` `Got 2 off queue` `Got 3 off queue` `Got 4 off queue` `Got 1 off queue` `Got 1 off queue` `Got 0 off queue` `Got 4 off queue` `Done.` If you can, it’s better to aim for having short executor jobs, and in these cases, a queue (for communication) won’t be necessary. This isn’t always possible, though, and in such situations, the Janus queue can be the most convenient solution to buffer and distribute data between threads and coroutines. ### aiohttp
 `aiohttp`  brings all things HTTP to  `asyncio` , including support for HTTP clients and servers, as well as WebSocket support. Let’s jump straight into code examples, starting with simplicity itself: “Hello World.” **92 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
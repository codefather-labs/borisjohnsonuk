`>>>` `>>>` ` ` `async` ` ` `def` ` ` `main` `(` `f` `:` ` ` `asyncio` `.` `Future` `):` `...` `     ` `await` ` ` `asyncio` `.` `sleep` `(` `1` `)` `...` `     ` `try` `:` `...` `         ` `f` `.` `set_result` `(` `'I have finished.'` `)` `  ` `...` `     ` `except` ` ` `RuntimeError` ` ` `as` ` ` `e` `:` `...` `         ` `print` `(` `f` `'No longer allowed: ` `{e}` `'` `)` `...` `         ` `f` `.` `cancel` `()` `  ` `...` `>>>` ` ` `loop` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` `>>>` ` ` `fut` ` ` `=` ` ` `asyncio` `.` `Task` `(` `asyncio` `.` `sleep` `(` `1` `_000_000` `))` `  ` `>>>` ` ` `print` `(` `fut` `.` `done` `())` `False` `>>>` ` ` `loop` `.` `create_task` `(` `main` `(` `fut` `))` `<` `Task` ` ` `pending` ` ` `name` `=` `'Task-2'` ` ` `coro` `=<` `main` `()` ` ` `running` ` ` `at` ` ` `<` `console` `>` `:` `1` `>>` `>>>` ` ` `with` ` ` `suppress` `(` `asyncio` `.` `CancelledError` `):` `...` `     ` `loop` `.` `run_until_complete` `(` `fut` `)` `...` `No` ` ` `longer` ` ` `allowed` `:` ` ` `Task` ` ` `does` ` ` `not` ` ` `support` ` ` `set_result` ` ` `operation` `>>>` ` ` `print` `(` `fut` `.` `done` `())` `True` `>>>` ` ` `print` `(` `fut` `.` `cancelled` `())` `  ` `True` The only difference is that we create a  `Task`  instance instead of a  `Future` . Of course, the  `Task`  API requires us to provide a coroutine; we just use  `sleep()` because it’s convenient. A  `Task`  instance is being passed in. It satisfies the type signature of the function (because  `Task`  is a subclass of  `Future` ), but since Python 3.8, we’re no longer allowed to call  `set_result()`  on a  `Task` : an attempt will raise  `RuntimeError` . The idea is that a  `Task`  represents a running coroutine, so the result should always come only from that. We can, however, still  `cancel()`  a task, which will raise  `CancelledError`  inside the underlying coroutine. #### Create a Task? Ensure a Future? Make Up Your Mind!
 In  “Quickstart” on page 22 , I said that the way to run coroutines was to use `asyncio.create_task()` . Before that function was introduced, it was necessary to obtain a  `loop`  instance and use  `loop.create_task()`  to do the same thing. This can, in fact, also be achieved with a different module-level function: `asyncio.ensure_future()` . Some developers recommended  `create_task()` , while others recommended  `ensure_future()` . **42 ** **| ** **Chapter 3: Asyncio Walk-Through**
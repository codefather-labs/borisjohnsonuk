Example: Adding an Item to a List Note 
##Opcode Predictions 

 Some opcodes come in pairs, making it possible to predict the second code when the ﬁrst is run. For example,  COMPARE_OP  is often followed by  POP_JUMP_IF_FALSE  or  POP_JUMP_IF_TRUE . “Verifying the prediction costs a single high-speed test of a register variable against a constant. If the pairing was good, then the processor’s own internal branch prediction has a high likelihood of success, resulting in a nearly zero-overhead transition to the next opcode. A successful prediction saves a trip through the eval-loop, including its unpredictable switch-case branch. Combined with the processor’s internal branch prediction, a successful PREDICT has the eﬀect of making the two opcodes run as if they were a single new opcode with the bodies combined.” If collecting opcode statistics, you have two choices: 1. Keep the predictions turned-on and interpret the results as if some opcodes had been combined 2. Turn oﬀ predictions so that the opcode frequency counter updates for both opcodes Opcode prediction is disabled with threaded code since the latter allows the CPU to record separate branch prediction information for each opcode. Some of the operations, such as  CALL_FUNCTION  and  CALL_METHOD , have an operation argument referencing another compiled function. In these cases, another frame is pushed to the frame stack in the thread. The evaluation loop is then run for that function until the function completes. Each time a new frame is created and pushed onto the stack, the value of the frame’s  f_back  is set to the current frame before the new one is created. 178
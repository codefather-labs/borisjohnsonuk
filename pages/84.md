not exposed in the  `asyncio`  API, which is why we cannot call  `shutdown()`  on it and were forced to create our own executor instance. Finally, we have a strategy with general applicability: you can call  `run_in_executor()` anywhere, and your program will still shut down cleanly, even if executor jobs are still running after all the async tasks have completed. I strongly urge you to experiment with the code examples shown here and try different strategies to create tasks and executor jobs, staggering them in time and trying to shut down cleanly. I expect that a future version of Python will allow the `asyncio.run()`  function to wait (internally) for executor jobs to finish, but I hope that the discussion in this section is still useful for you to develop your thinking around clean shutdown handling. **Starting Up and Shutting Down (Gracefully!) ** **| ** **73**
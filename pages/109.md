Generally, you’ll find that  `aiohttp`  has a simple API and “stays out of your way” while you develop your applications. In the next section, we’ll look at using ZeroMQ with  `asyncio` , which has the curious effect of making socket programming quite enjoyable. ### ØMQ (ZeroMQ)
 Programming is a science dressed up as art, because most of us don’t understand the physics of software and it’s rarely, if ever, taught. The physics of software is not algorithms, data structures, languages, and abstractions. These are just tools we make, use, and throw away. The real physics of software is the physics of people. Specifically, it’s about our limitations when it comes to complexity and our desire to work together to solve large problems in pieces. This is the science of programming: make building blocks that people can understand and use easily, and people will work together to solve the very largest problems. —Pieter Hintjens,  *ZeroMQ: Messaging for Many Applications* ØMQ (or  ZeroMQ ) is a popular language-agnostic library for networking applications: it provides “smart” sockets. When you create ØMQ sockets in code, they resemble regular sockets, with recognizable method names like  `recv()`  and  `send()` and so on—but internally these sockets handle some of the more annoying and tedious tasks required for working with conventional sockets. One of the features it provides is management of message passing, so you don’t have to invent your own protocol and count bytes on the wire to figure out when all the bytes for a particular message have arrived—you simply send whatever you consider to be a “message,” and the whole thing arrives on the other end intact. Another great feature is automatic reconnection logic. If the server goes down and comes back up later, the client ØMQ socket will  *automatically*  reconnect. And even better, messages your code sends into the socket will be buffered during the disconnected period, so they will all still be sent out when the server returns. These are some of the reasons ØMQ is sometimes referred to as  *brokerless*  messaging : it provides some of the features of message broker software directly in the socket objects themselves. ØMQ sockets are already implemented as asynchronous internally (so they can maintain many thousands of concurrent connections, even when used in threaded code), but this is hidden from us behind the ØMQ API. Nevertheless, support for Asyncio has been added to the  PyZMQ  Python bindings for the ØMQ library, and in this section we’re going to look at several examples of how you might incorporate these smart sockets into your Python applications. **98 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
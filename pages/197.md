The CPython Memory Allocator uint size = (uint)(nbytes -  1 ) >> ALIGNMENT_SHIFT; poolp pool = usedpools[size + size]; block *bp; Next, a check is done to see if there is an available ( 'used' ) pool for the class size index. If the freeblock list is at the end of the pool, then there are still clean blocks available in that pool.  pymalloc_pool_extend()  is called to extend the  freeblock  list: if  (LIKELY(pool != pool->nextpool)) { /* * There is a used pool for this size class. * Pick up the head block of its free list. */ ++pool->ref.count; bp = pool->freeblock; assert(bp != NULL); if  (UNLIKELY((pool->freeblock = *(block **)bp) == NULL)) { // Reached the end of the free list, try to extend it. pymalloc_pool_extend(pool, size); } } If there were no available pools, a new pool is created and the Ô¨Årst block is returned. The  allocate_from_new_pool()  function adds the new pool to the  usedpools  list automatically: else  { /* There isn't a pool of the right size class immediately * available: use a free pool. */ bp = allocate_from_new_pool(size); } return  ( void  *)bp; } Finally, the new block address is returned. 197
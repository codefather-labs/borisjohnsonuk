3  Obtain  `boltons`  with  `pip install boltons` . `async` ` ` `def` ` ` `get_patron` `(` `conn` `,` ` ` `id` `:` ` ` `int` `)` ` ` `->` ` ` `dict` `:` `  ` `    ` `if` ` ` `id` ` ` `not` ` ` `in` ` ` `CACHE` `:` `        ` `logger` `.` `info` `(` `f` `'id=` `{id}` ` Cache miss'` `)` `        ` `record` ` ` `=` ` ` `await` ` ` `conn` `.` `fetchrow` `(` `SELECT` `,` ` ` `id` `)` `  ` `        ` `CACHE` `[` `id` `]` ` ` `=` ` ` `record` ` ` `and` ` ` `dict` `(` `record` `.` `items` `())` `    ` `return` ` ` `CACHE` `[` `id` `]` `def` ` ` `db_event` `(` `conn` `,` ` ` `pid` `,` ` ` `channel` `,` ` ` `payload` `):` `  ` `    ` `event` ` ` `=` ` ` `loads` `(` `payload` `)` `  ` `    ` `logger` `.` `info` `(` `'Got DB event:` `\n` `'` ` ` `+` ` ` `dumps` `(` `event` `,` ` ` `indent` `=` `4` `))` `    ` `id` ` ` `=` ` ` `event` `[` `'id'` `]` `    ` `if` ` ` `event` `[` `'type'` `]` ` ` `==` ` ` `'INSERT'` `:` `        ` `CACHE` `[` `id` `]` ` ` `=` ` ` `event` `[` `'data'` `]` `    ` `elif` ` ` `event` `[` `'type'` `]` ` ` `==` ` ` `'UPDATE'` `:` `        ` `CACHE` `[` `id` `]` ` ` `=` ` ` `event` `[` `'data'` `][` `'new'` `]` `  ` `    ` `elif` ` ` `event` `[` `'type'` `]` ` ` `==` ` ` `'DELETE'` `:` `        ` `CACHE` `[` `id` `]` ` ` `=` ` ` `None` `async` ` ` `def` ` ` `create_table_if_missing` `(` `conn` `):` `  ` `    ` `if` ` ` `not` ` ` `await` ` ` `conn` `.` `fetchval` `(` `EXISTS` `):` `        ` `await` ` ` `conn` `.` `fetchval` `(` `CREATE_TABLE` `)` `        ` `await` ` ` `create_notify_trigger` `(` `            ` `conn` `,` ` ` `channel` `=` `'chan_patron'` `)` `        ` `await` ` ` `add_table_triggers` `(` `            ` `conn` `,` ` ` `table` `=` `'patron'` `)` You have to add triggers to the database in order to get notifications when data changes. I’ve created these handy helpers to create the trigger function itself (with `create_notify_trigger` ) and to add the trigger to a specific table (with `add_table_triggers` ). The SQL required to do this is somewhat out of scope for this book, but it’s still crucial to understanding how this case study works. I’ve included the annotated code for these triggers in  Appendix B . The third-party  `boltons`  package provides a bunch of useful tools, not the least of which is the  `LRU`  cache, a more versatile option than the  `@lru_cache`  decorator in the  `functools`  standard library module. 3 This block of text holds all the SQL for the standard CRUD operations. Note that I’m using native PostgreSQL syntax for the parameters:  `$1` ,  `$2` , and so on. There is nothing novel here, and it won’t be discussed further. Create the cache for this app instance. **124 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
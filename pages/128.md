Next, we’ll update the record and check the results: `$ curl -d '{"name": "Eric", "fav_dish": "SPAM Bruschetta"}' \` `    -H "Content-Type: application/json" \` `    -X PUT \` `    http://localhost:8000/patron/37` `$ curl -X GET http://localhost:8000/patron/37` `{"msg":"ok"}` `{"id":37,"name":"Eric","fav_dish":"SPAM Bruschetta"}` Updating a resource is similar to creating one, with two key differences: •  The HTTP request method ( `-X` ) is  `PUT` , not  `POST` . •  The URL now requires the  `id`  field to specify which resource to update. Finally, we can delete the record and verify its deletion with the following commands: `$ curl -X DELETE http://localhost:8000/patron/37` `$ curl -X GET http://localhost:8000/patron/37` `{"msg":"ok"}` `null` As you can see,  `null`  is returned when you try to  `GET`  a record that doesn’t exist. So far this all looks quite ordinary, but our objective is not only to make a CRUD API —we want to look at cache invalidation. So, let’s turn our attention toward the cache. Now that we have a basic understanding of our app’s API, we can look at the application logs to see timing data for each request: this will tell us which requests are cached, and which hit the DB. When the server is first started up, the cache is empty; it’s a memory cache, after all. We’re going to start up our server, and then in a separate shell run two  `GET`  requests in quick succession: `$ curl -X GET http://localhost:8000/patron/29` `$ curl -X GET http://localhost:8000/patron/29` `{"id":29,"name":"John Cleese","fav_dish":"Gravy on Toast"}` `{"id":29,"name":"John Cleese","fav_dish":"Gravy on Toast"}` **asyncpg and Sanic ** **| ** **117**
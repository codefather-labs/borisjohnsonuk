Asynchronous Generators async def  scan(start, end, host): tasks  =  [] results  =  [] for  port  in  range(start, end): tasks.append(check_port(host, port, results)) await  asyncio.gather( * tasks) return  results if  __name__  ==  '__main__' : start  =  time.time() host  =  "localhost" # pick a host you own results  =  asyncio.run(scan( 80 ,  100 , host)) for  result  in  results: print( "Port  {0}  is open" .format(result)) print( "Completed scan in  {0}  seconds" .format(time.time()  -  start)) Finally, this scan completes in just over 1 second: $ python portscanner_async.py Port 80 is open Completed scan in 1.0058400630950928 seconds 
#Asynchronous Generators 

 The concepts you have learned so far, generators and coroutines can be combined into a type -  asynchronous generators . If a function is declared with both the  async  keyword and it contains a  yield  statement, it is converted into an async generator object when called. Like generators, async generators must be executed by something that understands the protocol. In place of  __next__() , async generators have a method  __anext__() . A regular  for  loop would not understand an async generator, so instead, the  async for  statement is used. 281
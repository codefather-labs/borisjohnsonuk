Using the Crash Handler 
#Using the Crash Handler 

 In C, if an application tries to read or write to an area of memory that it shouldn’t be, a segmentation fault is raised. This fault halts the running process immediately to stop it from doing any damage to other applications. Segmentation faults can also happen when you try to read from memory that contains no data, or an invalid pointer. If CPython causes a segmentation fault, you get very little information about what happened: [1] 63476 segmentation fault ./python portscanner.py CPython comes with a builtin fault handler. If you start CPython with -X faulthandler , or  -X dev , instead of printing the system segmentation fault message, the fault handler will print the running threads and the Python stack trace to where the fault occurred: Fatal Python error: Segmentation fault Thread 0x0000000119021dc0 (most recent call first): File "/cpython/Lib/threading.py", line 1039 in _wait_for_tstate_lock File "/cpython/Lib/threading.py", line 1023 in join File "/cpython/portscanner.py", line 26 in main File "/cpython/portscanner.py", line 32 in <module> [1] 63540 segmentation fault ./python -X dev portscanner.py This feature is also helpful when developing and testing C extensions for CPython. 
#Compiling Debug Support 

 To get meaningful information from the debugger, the debug symbols must be compiled into CPython. Without these symbols, the stack traces within a debug session won’t contain the correct function names, the variable names, or ﬁle names. 332
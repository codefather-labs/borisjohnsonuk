•  Creating a  *task*  to be run on the loop •  Waiting for multiple tasks to complete •  Closing the loop after all concurrent tasks have completed In this section, we’re going to look at those core features and see how to hit the ground looping with event-based programming in Python. The “Hello World” of Asyncio in Python looks like  Example 3-1 . *Example 3-1. * *The* * “Hello World” of Asyncio* `# quickstart.py` `import` ` ` `asyncio` `,` ` ` `time` `async` ` ` `def` ` ` `main` `():` `    ` `print` `(` `f` `'{time.ctime()} Hello!'` `)` `    ` `await` ` ` `asyncio` `.` `sleep` `(` `1.0` `)` `    ` `print` `(` `f` `'{time.ctime()} Goodbye!'` `)` `asyncio` `.` `run` `(` `main` `())` `  ` `asyncio`  provides a  `run()`  function to execute an  `async def`  function and all other coroutines called from there, like  `sleep()`  in the  `main()`  function. Here’s the output from running  Example 3-1 : `$ ` `python quickstart.py` `Sun Aug 18 02:14:34 2019 Hello!` `Sun Aug 18 02:14:35 2019 Goodbye!` In practice, most of your Asyncio-based code will use the  `run()`  function shown here, but it’s important to understand a little more about what that function is doing for you. This understanding is important because it will influence how you design larger applications. Example 3-2  is what I’ll call a “Hello-ish World” example. It isn’t exactly the same as what  `run()`  does, but it’s close enough to introduce the ideas that we’ll build on throughout the rest of the book. You’ll need a basic knowledge of coroutines (discussed in depth later in this chapter), but try to follow along anyway and focus on the high-level concepts for now. *Example 3-2. * *The* * “Hello-ish World” of Asyncio* `# quickstart.py` `import` ` ` `asyncio` `import` ` ` `time` **Quickstart ** **| ** **23**
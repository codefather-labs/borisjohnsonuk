onto its queue,  `SEND_QUEUES[writer]`  (check the code for  `send_client()` ). It’s important to use a value on the queue, rather than outright cancellation, because there may already be data on that queue and we want that data to be sent out before  `send_client()`  is ended. Wait for that sender task to finish… …then remove the entry in the  `SEND_QUEUES`  collection (and in the next line, we also remove the  `sock`  from the  `SUBSCRIBERS`  collection as before). The  `send_client()`  coroutine function is very nearly a textbook example of pulling work off a queue. Note how the coroutine will exit only if  `None`  is placed onto the queue. Note also how we suppress  `CancelledError`   *inside*  the loop: this is because we want this task to be closed only by receiving a  `None`  on the queue. This way, all pending data on the queue can be sent out before shutdown. `chan_sender()`  is the distribution logic for a channel: it sends data from a dedicated channel  `Queue`  instance to all the subscribers on that channel. But what happens if there are no subscribers for this channel yet? We’ll just wait a bit and try again. (Note, though, that the queue for this channel,  `CHAN_QUEUES[name]` , will keep filling up.) As in our previous broker implementation, we do something special for channels whose name begins with  `/queue` : we rotate the deque and send only to the first entry. This acts like a crude load-balancing system because each subscriber gets different messages off the same queue. For all other channels, all subscribers get all the messages. We’ll wait here for data on the queue, and exit if  `None`  is received. Currently, this isn’t triggered anywhere (so these  `chan_sender()`  coroutines live forever), but if logic were added to clean up these channel tasks after, say, some period of inactivity, that’s how it would be done. Data has been received, so it’s time to send to subscribers. We do not do the sending here: instead, we place the data onto each subscriber’s own send queue. This decoupling is necessary to make sure that a slow subscriber doesn’t slow down anyone else receiving data. And furthermore, if the subscriber is so slow that their send queue fills up, we don’t put that data on their queue; i.e., it is lost. The preceding design produces the same output as the earlier, simplistic implementation, but now we can be sure that a slow listener will not interfere with message distribution to other listeners. **Streams (Standard Library) ** **| ** **87**
Garbage Collection Freeing Objects Once unreachable objects have been determined, they can be (carefully) freed following these stages. The approach depends on whether the type implements the old or the new ﬁnalizer slot: 1. If an object has deﬁned a ﬁnalizer in the legacy  tp_del  slot, it cannot safely be deleted and is marked as  uncollectable . These are added to the  gc.garbage  list for the developer to destroy manually. 2. If an object has deﬁned a ﬁnalizer in the  tp_finalize  slot, mark the objects as ﬁnalized to avoid calling them twice. 3. If an object in (2) has been “resurrected” by being initialized again, the GC reruns the collection cycle. 4. For all objects, call the  tp_clear  slot. This slot changes the reference count,  ob_refcnt , to 0, triggering the freeing of memory. 
##Generational GC 

 Generational garbage collection is a technique based on the observation that most (80%+) objects are destroyed shortly after being created. CPython’s GC uses three generations that have thresholds to trigger their collections. The youngest generation ( 0 ) has a high threshold to avoid the collection loop being run too frequently. If an object survives the GC, it will move to the second generation, and then the third. In the collection function, a single generation is targeted, and it merges younger generations into it before execution. For this reason, if you run  collect()  on generation 1, it will collect generation  0 . Likewise, running collect on generation  2  will  collect()  generations  0 and  1 . When objects are instantiated, the generational counters are incremented. When the counter reaches a user-deﬁned threshold, 222
Multi-Process Parallelism finally : child_write_lock.release() if  __name__  ==  '__main__' : mp.set_start_method( 'spawn' ) pool_manager  =  mp.Manager() with  mp.Pool( 2 )  as  pool: parent_pipe, child_pipe  =  mp.Pipe() parent_read_lock  =  mp.Lock() child_write_lock  =  mp.Lock() results  =  [] for  i  in  range( 110 ,  150 ,  10 ): parent_pipe.send(i) pool.apply_async(to_celcius, args = (child_pipe, parent_pipe, child_write_lock, parent_read_lock)) print(child_pipe.recv()) parent_pipe.close() child_pipe.close() Now the worker processes will wait to acquire a lock before receiving data, and wait again to acquire another lock to send data: Parent Process Worker Pool Worker 0 Worker 1 [110, 120, 130, 140] Parent Pipe Child Pipe 010101010100011100 100101111001110011 recv() send() (Waiting) (Busy) send() This example would suit situations where the data going over the pipe is large because the chance of a collision is higher. 251
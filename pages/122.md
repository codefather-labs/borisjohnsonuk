`            dob date` `        )'''` `    ` `)` `  ` `    ` `pk` ` ` `=` ` ` `await` ` ` `conn` `.` `fetchval` `(` `  ` `        ` `'INSERT INTO users(name, dob) VALUES($1, $2) '` `        ` `'RETURNING id'` `,` ` ` `'Bob'` `,` ` ` `datetime` `.` `date` `(` `1984` `,` ` ` `3` `,` ` ` `1` `)` `    ` `)` `    ` `async` ` ` `def` ` ` `get_row` `():` `  ` `        ` `return` ` ` `await` ` ` `conn` `.` `fetchrow` `(` `  ` `            ` `'SELECT * FROM users WHERE name = $1'` `,` `            ` `'Bob'` `        ` `)` `    ` `print` `(` `'After INSERT:'` `,` ` ` `await` ` ` `get_row` `())` `  ` `    ` `await` ` ` `conn` `.` `execute` `(` `        ` `'UPDATE users SET dob = $1 WHERE id=1'` `,` `        ` `datetime` `.` `date` `(` `1985` `,` ` ` `3` `,` ` ` `1` `)` `  ` `    ` `)` `    ` `print` `(` `'After UPDATE:'` `,` ` ` `await` ` ` `get_row` `())` `    ` `await` ` ` `conn` `.` `execute` `(` `        ` `'DELETE FROM users WHERE id=1'` `    ` `)` `    ` `print` `(` `'After DELETE:'` `,` ` ` `await` ` ` `get_row` `())` `if` ` ` `__name__` ` ` `==` ` ` `'__main__'` `:` `    ` `asyncio` `.` `run` `(` `main` `())` I’ve hidden some boilerplate away in a tiny  `util`  module to simplify things and keep the core message. The  `Database`  class gives us a context manager that will create a new database for us—in this, case named  `test` —and will destroy that database when the context manager exits. This turns out to be very useful when experimenting with ideas in code. Because no state is carried over between experiments, you start from a clean database every time. Note that this is an  `async with`  context manager; we’ll talk more about that later, but for now, the focal area of this demo is what happens inside the  `demo()`  coroutine. The  `Database`  context manager has provided us with a  `Connection`  instance, which is immediately used to create a new table,  `users` . I use  `fetchval()`  to insert a new record. While I could have used  `execute()`  to do the insertion, the benefit of using  `fetchval()`  is that I can obtain the  `id`  of the newly inserted record, which I store in the  `pk`  identifier. **asyncpg and Sanic ** **| ** **111**
Multi-Process Parallelism Semaphores are used by CPython for multiprocessing because they are both thread-safe and process-safe. The Operating System handles any potential deadlocks of reading or writing to the same semaphore. The implementation of these semaphore API functions is located in a C extension module  Modules _multiprocessing semaphore.c . This extension module oﬀers a single method for creating, locking, releasing semaphores, and other operations. The call to the Operating System is through a series of Macros, which are compiled into diﬀerent implementations depending on the Operating System platform. For Windows, the  <winbase.h>  API functions for semaphores  are used: #define SEM_CREATE(name, val, max) CreateSemaphore(NULL, val, max, NULL) #define SEM_CLOSE(sem) (CloseHandle(sem) ? 0 : -1) #define SEM_GETVALUE(sem, pval) _GetSemaphoreValue(sem, pval) #define SEM_UNLINK(name) 0 For POSIX, the macros use the  <semaphore.h>  API is used : #define SEM_CREATE(name, val, max) sem_open(name, O_CREAT | O_EXCL, 0600, val) #define SEM_CLOSE(sem) sem_close(sem) #define SEM_GETVALUE(sem, pval) sem_getvalue(sem, pval) #define SEM_UNLINK(name) sem_unlink(name) Queues Queues are a great way of sending small data to and from multiple processes. If you adapt the multiprocessing example before to use a  multiprocessing Manager()  instance, and create two queues: 1.  inputs  to hold the input Fahrenheit values 2.  outputs  to hold the resulting Celcius values Change the pool size to  2  so that there are two workers: 245
Multithreading • Access to  Files ,  Locks , and  Sockets  on the Operating System The biggest limitation to scaling a single process is that the Operating System will have a single  Program Counter  for that executable. To get around this, modern Operating Systems allow processes to signal the Operating System to branch their execution into multiple threads. Each thread will have its own Program Counter, but use the same resources as the host process. Each thread also has it’s own call stack, so it can be executing a diﬀerent function. Because multiple threads can read and write to the same memory space, collisions could occur. The solution to this is  thread safety and involves making sure that memory space is locked by a single thread before it is accessed. A single process with 3 threads would have a structure: Heap Python Objects Process Memory Process CPython Runtime Files Locks Sockets Compiled Modules Instructions Stack Program Counter Thread 0 Stack Program Counter Thread 1 Stack Program Counter Thread 2 Stack 256
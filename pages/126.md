Symbol Tables For example, if you create a method called  resolve_names()  in one class and declare another method with the same name in another class. Inside the module, you want to be sure which one is called. The symtable serves this purpose, as well as ensuring that variables declared within a narrow scope don’t automatically become globals. The symbol table struct, ( symtable ), has the following ﬁelds: Field Type Purpose st_filename PyObject *  ( str ) Name of ﬁle being compiled st_cur _symtable_entry * Current symbol table entry st_top _symtable_entry * Symbol table entry for the module st_blocks PyObject *  ( dict ) Map of AST node addresses to symbol table entries st_stack PyObject *  ( list ) Stack of namespace info st_global PyObject *  ( dict ) Reference to the symbols in  st_top ( st_top->ste_symbols ) st_nblocks int Number of blocks used st_private PyObject *  ( str ) Name of current class or NULL st_future PyFutureFeatures * Module’s future features that aﬀect the symbol table recursion_- depth int Current recursion depth recursion_- limit int Recursion limit before  RecursionError  is raised. Set by  Py_SetRecursionLimit() 
##Using the 

  symtable 
## Standard Library Module 

 Some of the symbol table C API is exposed in Python via  the  symtable module  in the standard library. Using another module called  tabulate  (available  on PyPi ), you can create a script to print a symbol table. Symbol tables can be nested, so if a module contains a function or class, that will have a symbol table. Create a script called  symviz.py  with a recursive  show()  function: 126
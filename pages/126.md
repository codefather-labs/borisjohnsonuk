
![page_126_0](images/page_126_0.png)
 In point 8 for the preceding code, I created a dedicated connection for each channel I want to listen on. This is expensive since it means that a PostgreSQL worker will be completely tied up for every channel being listened to. A much better design would be to use one connection for multiple channels. Once you have worked through this example, try to modify the code to use a single connection for multiple channel listeners. Now that you have an understanding of the basic building blocks of  `asyncpg` , we can explore it further with a really fun case study: using PostgreSQL’s built-in support for sending event notifications to perform cache invalidation! #### Case Study: Cache Invalidation
 There are two hard things in computer science: cache invalidation, naming things, and off-by-one errors. —Phil Karlton It is common in web services and web applications that the persistence layer, i.e., the backing database (DB), becomes the performance bottleneck sooner than any other part of the stack. The application layer can usually be scaled horizontally by running more instances, whereas it’s trickier to do that with a database. This is why it’s common practice to look at design options that can limit excessive interaction with the database. The most common option is to use  *caching*  to “remember” previously fetched database results and replay them when asked, thus avoiding subsequent calls to the DB for the same information. However, what happens if one of your app instances writes new data to the database while another app instance is still returning the old, stale data from its internal cache? This is a classic  *cache invalidation*  problem, and it can be very difficult to resolve in a robust way. Our attack strategy is as follows: 1.  Each app instance has an in-memory cache of DB queries. 2.  When one writes new data to the database, the database alerts all of the connected app instances of the new data. 3.  Each app instance then updates its internal cache accordingly. This case study will highlight how PostgreSQL, with its built-in support for event updates via the  `LISTEN`  and  `NOTIFY`  commands, can simply  *tell us*  when its data has changed. **asyncpg and Sanic ** **| ** **115**
`mystery_meat` ` ` `=` ` ` `asyncio` `.` `ensure_future` `(` `task` `)` `  ` `assert` ` ` `mystery_meat` ` ` `is` ` ` `task` `  ` A simple do-nothing coroutine function. We just need something that can make a coroutine. We make the coroutine object by calling the function directly. Your code will rarely do this, but I want to be explicit here (a few lines down) that we’re passing a coroutine object into each of  `create_task()`  and  `ensure_future()` . Obtain the loop. First off, we use  `loop.create_task()`  to schedule our coroutine on the loop, and we get a new  `Task`  instance back. We verify the type. So far, nothing interesting. We show that  `asyncio.ensure_future()`  can be used to perform the same act as `create_task()` : we passed in a coroutine and we got back a  `Task`  instance (and the coroutine has been scheduled to run on the loop)! If you’re passing in a coroutine,  there  is  no  difference  between  `loop.create_task()`   and `asyncio.ensure_future()` . But what happens if we pass a  `Task`  instance to  `ensure_future()` ? Note that we’re passing in a  `Task`  instance that was already created by  `loop.create_task()`  in step 4. We get back  *exactly*  the same  `Task`  instance as we passed in: it passes through unchanged. What’s the point of passing  `Future`  instances straight through? And why do two different things with the same function? The answer is that  `ensure_future()`  is intended to be used  *by framework authors*  to provide APIs  *to end-user developers*  that can handle both kinds of parameters. Don’t believe me? Here it is from the ex-BDFL himself: The point of  `ensure_future()`  is if you have something that could either be a coroutine or a  `Future`  (the latter includes a  `Task`  because that’s a subclass of  `Future` ), and you want to be able to call a method on it that is only defined on  `Future`  (probably about the only useful example being  `cancel()` ). When it is already a  `Future`  (or  `Task` ), this does nothing; when it is a coroutine, it wraps it in a  `Task` . If you know that you have a coroutine and you want it to be scheduled, the correct API to use is  `create_task()` . The only time when you should be calling  `ensure_future()` is when you are providing an API (like most of asyncio’s own APIs) that accepts either **44 ** **| ** **Chapter 3: Asyncio Walk-Through**
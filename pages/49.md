You’re going to see the discouraged function in much existing code, because the newer function,  `get_running_loop()` , was introduced much later, in Python 3.8. Thus, it will be useful in practice to have a basic idea of how the older method works, so we’ll look at both. Let’s start with  Example 3-12 . *Example 3-12. Always getting the same event loop* `>>>` ` ` `loop` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` `>>>` ` ` `loop2` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` `>>>` ` ` `loop` ` ` `is` ` ` `loop2` `  ` `True` Both identifiers,  `loop`  and  `loop2` , refer to the same instance. This means that if you’re inside a coroutine function and you need access to the loop instance, it’s fine to call  `get_event_loop()`  or  `get_running_loop()`  to obtain it. You *do not*  need to pass an explicit  `loop`  parameter through all your functions. The situation is different if you’re a framework designer: it would be better to design your functions to accept a  `loop`  parameter, just in case your users are doing something unusual with  event loop policies . Policies are out of scope for this book, and we’ll say no more about them. So if  `get_event_loop()`  and  `get_running_loop()`  work the same, why do they both exist? The  `get_event_loop()`  method works only within the  *same thread* . In fact, `get_event_loop()`  will fail if called inside a new thread unless you specifically create a new loop with  `new_event_loop()` ,  *and*  set that new instance to be  *the*  loop for that thread by calling  `set_event_loop()` . Most of us will only ever need (and want!) a single loop instance running in a single thread. This is nearly the entire point of async programming in the first place. In contrast,  `get_running_loop()`  (the recommended method) will always do what you expect: because it can be called only within the context of a coroutine, a task, or a function called from one of those, it always provides the  *current*  running event loop, which is almost always what you want. The introduction of  `get_running_loop()`  has also simplified the spawning of background tasks. Consider  Example 3-13 , a coroutine function inside which additional tasks are created and  *not*  awaited. *Example 3-13. Creating tasks* `async` ` ` `def` ` ` `f` `():` `    ` `# Create some tasks!` `    ` `loop` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` **38 ** **| ** **Chapter 3: Asyncio Walk-Through**
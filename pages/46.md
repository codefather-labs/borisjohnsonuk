Before we close out this section and move on to the event loop, it is useful to look at how coroutines may be fed exceptions. This is most commonly used for cancellation: when you call  `task.cancel()` , the event loop will internally use  `coro.throw()`  to raise  `asyncio.CancelledError`   *inside*  your coroutine ( Example 3-8 ). *Example 3-8. Using coro.throw() to inject exceptions into a coroutine* `>>>` ` ` `coro` ` ` `=` ` ` `f` `()` `  ` `>>>` ` ` `coro` `.` `send` `(` `None` `)` `>>>` ` ` `coro` `.` `throw` `(` `Exception` `,` ` ` `'blah'` `)` `  ` `Traceback` ` ` `(` `most` ` ` `recent` ` ` `call` ` ` `last` `):` `  ` `File` ` ` `"<stdin>"` `,` ` ` `line` ` ` `1` `,` ` ` `in` ` ` `<` `module` `>` `  ` `File` ` ` `"<stdin>"` `,` ` ` `line` ` ` `2` `,` ` ` `in` ` ` `f` `Exception` `:` ` ` `blah` `blah` As before, a new coroutine is created from the coroutine function  `f()` . Instead of doing another  `send()` , we call  `throw()`  and provide an exception class and a value. This raises an exception  *inside*  our coroutine, at the  `await`  point. The  `throw()`  method is used (internally in  `asyncio` ) for  *task cancellation* , which we can also demonstrate quite easily. Weâ€™re even going to go ahead in  Example 3-9  and handle the cancellation inside a new coroutine. *Example 3-9. Coroutine cancellation with CancelledError* `>>>` ` ` `import` ` ` `asyncio` `>>>` ` ` `async` ` ` `def` ` ` `f` `():` `...` `     ` `try` `:` `...` `         ` `while` ` ` `True` `:` ` ` `await` ` ` `asyncio` `.` `sleep` `(` `0` `)` `...` `     ` `except` ` ` `asyncio` `.` `CancelledError` `:` `  ` `...` `         ` `print` `(` `'I was cancelled!'` `)` `  ` `...` `     ` `else` `:` `...` `         ` `return` ` ` `111` `>>>` ` ` `coro` ` ` `=` ` ` `f` `()` `>>>` ` ` `coro` `.` `send` `(` `None` `)` `>>>` ` ` `coro` `.` `send` `(` `None` `)` `>>>` ` ` `coro` `.` `throw` `(` `asyncio` `.` `CancelledError` `)` ` ` `I` ` ` `was` ` ` `cancelled` `!` `  ` `Traceback` ` ` `(` `most` ` ` `recent` ` ` `call` ` ` `last` `):` `  ` `File` ` ` `"<stdin>"` `,` ` ` `line` ` ` `1` `,` ` ` `in` ` ` `<` `module` `>` `StopIteration` `  ` Our coroutine function now handles an exception. In fact, it handles the  *specific* exception type used throughout the  `asyncio`  library for task cancellation: `asyncio.CancelledError` . Note that the exception is being injected into the **Coroutines ** **| ** **35**
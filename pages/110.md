#### Case Study: Multiple Sockets
 Here’s a head-scratcher: if ØMQ provides sockets that are already asynchronous, in a way that is usable with threading, what is the point of using ØMQ with  `asyncio` ? The answer is cleaner code. To demonstrate, let’s look at a tiny case study in which you use multiple ØMQ sockets in the same application. First,  Example 4-15  shows the blocking version (this example is taken from the  zguide , the official guide for ØMQ). *Example 4-15. * *The* * traditional ØMQ approach* `# poller.py` `import` ` ` `zmq` `context` ` ` `=` ` ` `zmq` `.` `Context` `()` `receiver` ` ` `=` ` ` `context` `.` `socket` `(` `zmq` `.` `PULL` `)` `  ` `receiver` `.` `connect` `(` `"tcp://localhost:5557"` `)` `subscriber` ` ` `=` ` ` `context` `.` `socket` `(` `zmq` `.` `SUB` `)` `  ` `subscriber` `.` `connect` `(` `"tcp://localhost:5556"` `)` `subscriber` `.` `setsockopt_string` `(` `zmq` `.` `SUBSCRIBE` `,` ` ` `''` `)` `poller` ` ` `=` ` ` `zmq` `.` `Poller` `()` `  ` `poller` `.` `register` `(` `receiver` `,` ` ` `zmq` `.` `POLLIN` `)` `poller` `.` `register` `(` `subscriber` `,` ` ` `zmq` `.` `POLLIN` `)` `while` ` ` `True` `:` `    ` `try` `:` `        ` `socks` ` ` `=` ` ` `dict` `(` `poller` `.` `poll` `())` `  ` `    ` `except` ` ` `KeyboardInterrupt` `:` `        ` `break` `    ` `if` ` ` `receiver` ` ` `in` ` ` `socks` `:` `        ` `message` ` ` `=` ` ` `receiver` `.` `recv_json` `()` `        ` `print` `(` `f` `'Via PULL: ` `{message}` `'` `)` `    ` `if` ` ` `subscriber` ` ` `in` ` ` `socks` `:` `        ` `message` ` ` `=` ` ` `subscriber` `.` `recv_json` `()` `        ` `print` `(` `f` `'Via SUB: ` `{message}` `'` `)` ØMQ sockets have  *types* . This is a  `PULL`  socket. You can think of it as a  *receiveonly*  kind of socket that will be fed by some other  *send-only*  socket, which will be a  `PUSH`  type. The  `SUB`  socket is another kind of receive-only socket, and it will be fed a  `PUB` socket which is send-only. **ØMQ (ZeroMQ) ** **| ** **99**
`    ` `server` ` ` `=` ` ` `await` ` ` `asyncio` `.` `start_server` `(` `echo` `,` ` ` `host` `,` ` ` `port` `)` ` ` `    ` `async` ` ` `with` ` ` `server` `:` `        ` `await` ` ` `server` `.` `serve_forever` `()` `try` `:` `    ` `asyncio` `.` `run` `(` `main` `())` `except` ` ` `KeyboardInterrupt` `:` `    ` `print` `(` `'Bye!'` `)` This  `echo()`  coroutine function will be used (by the server) to create a coroutine for each connection made. The function is using the streams API for networking with  `asyncio` . To keep the connection alive, we’ll have an infinite loop to wait for messages. Return the data back to the sender, but in ALL CAPS. If this task is  *cancelled* , we’ll print a message. This code for starting a TCP server is taken directly from the Python 3.8 documentation. After starting the echo server, you can telnet to and interact with it: `$ ` `telnet 127.0.0.1 8888` `Trying 127.0.0.1...` `Connected to 127.0.0.1.` `Escape character is '^]'.` `hi!` `HI!` `stop shouting` `STOP SHOUTING` `^]` `telnet> ` `q/` `Connection closed.` The server output for that session looks like this (the server keeps running until we hit Ctrl-C): `$ ` `python telnetdemo.py` `New connection.` `Leaving Connection.` `^C` `Bye!` In the Telnet session just shown, the client (i.e., Telnet) closed the connection before the server was stopped, but let’s see what happens if we shut down our server while a connection is active. We’ll see the following output from the server process: `$ ` `python telnetdemo.py` `New connection.` **Starting Up and Shutting Down (Gracefully!) ** **| ** **59**
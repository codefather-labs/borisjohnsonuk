2  The  `asyncio`  API lets you do lots of wild things with multiple loop instances and threads, but this is not the right book to get into that. 99% of the time you’re going to use only a single, main thread for your app, as shown here. 3  Using the parameter name  `coro`  is a common convention in the API documentation. It refers to a  *coroutine* ; i.e., strictly speaking, the  *result*  of calling an  `async def`  function, and  *not*  the function itself. `async` ` ` `def` ` ` `main` `():` `    ` `print` `(` `f` `"{time.ctime()} Hello!"` `)` `    ` `await` ` ` `asyncio` `.` `sleep` `(` `1.0` `)` `    ` `print` `(` `f` `"{time.ctime()} Goodbye!"` `)` `loop` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` `  ` `task` ` ` `=` ` ` `loop` `.` `create_task` `(` `main` `())` `  ` `loop` `.` `run_until_complete` `(` `task` `)` `  ` `pending` ` ` `=` ` ` `asyncio` `.` `all_tasks` `(` `loop` `=` `loop` `)` `for` ` ` `task` ` ` `in` ` ` `pending` `:` `    ` `task` `.` `cancel` `()` `group` ` ` `=` ` ` `asyncio` `.` `gather` `(` `*` `pending` `,` ` ` `return_exceptions` `=` `True` `)` `  ` `loop` `.` `run_until_complete` `(` `group` `)` `  ` `loop` `.` `close` `()` `  ` `loop`  =  `asyncio.get_event_loop()` You need a loop instance before you can run any coroutines, and this is how you get one. In fact, anywhere you call it,  `get_event_loop()`  will give you the same `loop`  instance each time, as long as you’re using only a single thread. 2  If you’re inside an  `async def`  function, you should call  `asyncio.get_running_loop()` instead, which always gives you what you expect. This is covered in much more detail later in the book. `task`  =  `loop.create_task(coro)` In this case, the specific call is  `loop.create_task(main())` . Your coroutine function will not be executed until you do this. We say that  `create_task()`   *schedules* your coroutine to be run on the loop. 3  The returned  `task`  object can be used to monitor the status of the task (for example, whether it is still running or has completed), and can also be used to obtain a result value from your completed coroutine. You can cancel the task with  `task.cancel()` . `loop.run_until_complete(coro)` This call will  *block*  the current thread, which will usually be the main thread. Note that  `run_until_complete()`  will keep the loop running only until the given `coro`  completes—but all  *other*  tasks scheduled on the loop will also run while the loop is running. Internally,  `asyncio.run()`  calls  `run_until_complete()`  for you and therefore blocks the main thread in the same way. **24 ** **| ** **Chapter 3: Asyncio Walk-Through**
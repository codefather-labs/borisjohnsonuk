`  ` `try` `:` `    ` `while` ` ` `channel_name` ` ` `:` `=` ` ` `await` ` ` `read_msg` `(` `reader` `):` `  ` `      ` `data` ` ` `=` ` ` `await` ` ` `read_msg` `(` `reader` `)` `  ` `      ` `print` `(` `f` `'Sending to ` `{channel_name}` `: ` `{data[:19]}` `...'` `)` `      ` `conns` ` ` `=` ` ` `SUBSCRIBERS` `[` `channel_name` `]` `  ` `      ` `if` ` ` `conns` ` ` `and` ` ` `channel_name` `.` `startswith` `(` `b` `'/queue'` `):` `  ` `          ` `conns` `.` `rotate` `()` `  ` `          ` `conns` ` ` `=` ` ` `[` `conns` `[` `0` `]]` `  ` `      ` `await` ` ` `gather` `(` `*` `[` `send_msg` `(` `c` `,` ` ` `data` `)` ` ` `for` ` ` `c` ` ` `in` ` ` `conns` `])` ` ` `  ` `except` ` ` `asyncio` `.` `CancelledError` `:` `    ` `print` `(` `f` `'Remote ` `{peername}` ` closing connection.'` `)` `    ` `writer` `.` `close` `()` `    ` `await` ` ` `writer` `.` `wait_closed` `()` `  ` `except` ` ` `asyncio` `.` `IncompleteReadError` `:` `    ` `print` `(` `f` `'Remote ` `{peername}` ` disconnected'` `)` `  ` `finally` `:` `    ` `print` `(` `f` `'Remote ` `{peername}` ` closed'` `)` `    ` `SUBSCRIBERS` `[` `subscribe_chan` `]` `.` `remove` `(` `writer` `)` `  ` `async` ` ` `def` ` ` `main` `(` `*` `args` `,` ` ` `**` `kwargs` `):` `    ` `server` ` ` `=` ` ` `await` ` ` `asyncio` `.` `start_server` `(` `*` `args` `,` ` ` `**` `kwargs` `)` `    ` `async` ` ` `with` ` ` `server` `:` `        ` `await` ` ` `server` `.` `serve_forever` `()` `try` `:` `    ` `asyncio` `.` `run` `(` `main` `(` `client` `,` ` ` `host` `=` `'127.0.0.1'` `,` ` ` `port` `=` `25000` `))` `except` ` ` `KeyboardInterrupt` `:` `    ` `print` `(` `'Bye!'` `)` Imports from our  *msgproto.py*  module. A global collection of currently active subscribers. Every time a client connects, they must first send a channel name they’re subscribing to. A deque will hold all the subscribers for a particular channel. The  `client()`  coroutine function will produce a long-lived coroutine for each new connection. Think of it as a callback for the TCP server started in  `main()` . On this line, I’ve shown how the host and port of the remote peer can be obtained, for example, for logging. Our protocol for clients is the following: •  On first connect, a client  *must*  send a message containing the channel to subscribe to (here,  `subscribe_chan` ). •  Thereafter, for the life of the connection, a client sends a message to a channel by first sending a message containing the destination channel name, **78 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**

![page_22_0](images/page_22_0.png)
 `with` ` ` `Executor` `(` `max_workers` `=` `10` `)` ` ` `as` ` ` `exe` `:` `    ` `future` ` ` `=` ` ` `exe` `.` `submit` `(` `worker` `,` ` ` `data` `)` The  `ThreadPoolExecutor`  offers an extremely simple interface for running functions in a thread—and the best part is that, if needed, you can convert the pool of threads into a pool of subprocesses simply by using  `ProcessPoolExecutor`  instead. It has the same API as  `ThreadPoolExecutor` , which means that your code will be little affected by the change. The executor API is also used in  `asyncio`  and is described in the next chapter (see  Example 3-3 ). In general, you’ll prefer your tasks to be somewhat short-lived, so that when your program needs to shut down, you can simply call  `Executor.shutdown(wait=True)` and wait a second or two to allow the executor to complete. Most importantly: if at all possible, you should try to prevent your threaded code (in the preceding example, the  `worker()`  function) from accessing or writing to any global variables! Raymond Hettinger presented several great guidelines for safer threaded code at  PyCon Russia 2016  and  PyBay 2017 . I strongly urge you to add these videos to your watch list. ### Drawbacks of Threading
 [N]ontrivial multithreaded programs are incomprehensible to humans. It is true that the programming model can be improved through the use of design patterns, better granularity of atomicity (e.g., transactions), improved languages, and formal methods. However, these techniques merely chip away at the unnecessarily enormous nondeterminism of the threading model. The model remains intrinsically intractable. —Edward A. Lee  “The Problem with Threads” The drawbacks of threading have been mentioned in a few other places already, but for completeness let’s collect them here anyway: *Threading* * is * *difficult* Threading bugs and race conditions in threaded programs are  *the hardest*  kinds of bugs to fix. With experience, it is possible to design new software that is less prone to these problems, but in nontrivial, naively designed software, they can be nearly impossible to fix, even by experts. Really! *Threads* * are resource-intensive* Threads require extra operating system resources to create, such as preallocated, per-thread stack space that consumes process virtual memory up front. This is a big problem with 32-bit operating systems, because the address space per process **Drawbacks of Threading ** **| ** **11**
### Preface
 Python 3.4 introduced the  `asyncio`  library, and Python 3.5 produced the  `async`  and `await`  keywords to use it palatably. These new additions allow so-called  *asynchronous* programming. All of these new features, which I’ll refer to under the single name  *Asyncio* , have been received by the Python community somewhat warily; a segment of the community seems to see them as complex and difficult to understand. This view is not limited to beginners: several high-profile contributors to the Python community have expressed doubts about the complexity of the Asyncio API in Python, and educators in the community have expressed concern about how best to teach Asyncio to students. Most people with a few years’ experience with Python have used threads before, and even if you haven’t, you are still likely to have experienced  *blocking* . For example, if you’ve written programs using the wonderful  `requests`  library, you will surely have noticed that your program pauses for a bit while it does  `requests.get(url)` ; this is blocking behavior. For one-off tasks, this is fine; but if you want to fetch  *ten thousand*  URLs simultaneously, it’s going to be difficult to use  `requests` . Large-scale concurrency is one big reason to learn and use Asyncio, but the other big attraction of Asyncio over preemptive threading is safety: it will be much easier for you to avoid race condition bugs with Asyncio. My goal with this book is to give you a basic understanding of why these new features have been introduced and how to use them in your own projects. More specifically, I aim to provide the following: •  A critical comparison of  `asyncio`  and  `threading`  for concurrent network programming •  An understanding of the new  `async/await`  language syntax •  A general overview of the new  `asyncio`  standard library features in Python **vii**
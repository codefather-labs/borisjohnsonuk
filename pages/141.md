Assembly Both the sequential and control-flow graphs are used, but the controlflow graph is the one used by the DFS implementation. 
##Assembler C API 

 The assembler API has an entry point  assemble() . The  assemble()  function has a few responsibilities: • Calculate the number of blocks for memory allocation • Ensure that every block that falls oﬀ the end returns  None  (This is why every function returns  None , whether or not a  return  statement exists) • Resolve any jump statements oﬀsets that were marked as relative • Call  dfs()  to perform a depth-ﬁrst-search of the blocks • Emit all the instructions to the compiler • Call  makecode()  with the compiler state to generate the  PyCodeObject Python compile.c  line 6005 static  PyCodeObject * assemble( struct  compiler *c,  int  addNone) { ... if  (!c->u->u_curblock->b_return) { NEXT_BLOCK(c); if  (addNone) ADDOP_LOAD_CONST(c, Py_None); ADDOP(c, RETURN_VALUE); } ... dfs(c, entryblock, &a, nblocks); /* Can't modify the bytecode after computing jump offsets. */ assemble_jump_offsets(&a, c); /* Emit code in reverse postorder from dfs. */ 141
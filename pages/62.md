*Example 3-24. A traditional, nonasync iterator* `>>>` ` ` `class` ` ` `A` `:` `...` `     ` `def` ` ` `__iter__` `(` `self` `):` `   ` `...` `         ` `self` `.` `x` ` ` `=` ` ` `0` `  ` `...` `         ` `return` ` ` `self` `  ` `...` `     ` `def` ` ` `__next__` `(` `self` `):` `  ` `...` `         ` `if` ` ` `self` `.` `x` ` ` `>` ` ` `2` `:` `...` `             ` `raise` ` ` `StopIteration` `  ` `...` `         ` `else` `:` `...` `             ` `self` `.` `x` ` ` `+=` ` ` `1` `...` `             ` `return` ` ` `self` `.` `x` `  ` `>>>` ` ` `for` ` ` `i` ` ` `in` ` ` `A` `():` `...` `     ` `print` `(` `i` `)` `1` `2` `3` An  *iterator*  must implement the  `__iter__()`  special method. Initialize some state to the “starting” state. The  `__iter__()`  special method must return an  *iterable* ; i.e., an object that implements the  `__next__()`  special method. In this case, it’s the same instance, because `A`  itself also implements the  `__next__()`  special method. The  `__next__()`  method is defined. This will be called for every step in the iteration sequence until… … `StopIteration`  is raised. The  *returned values*  for each iteration are generated. Now you ask: what happens if you declare the  `__next__()`  special method as an `async def`  coroutine function? That will allow it to  `await`  some kind of I/O-bound operation—and this is pretty much exactly how  `async for`  works, except for some small details around naming. The specification (in PEP 492) shows that to use  `async` `for`  on an async iterator, several things are required in the async iterator itself: 1.  You must implement  `def __aiter__()` . (Note:  *not*  with  `async def` !) 2. ` __aiter__()`  must return an object that implements  `async def __anext__()` . 3. ` __anext__()`  must return a value for each iteration and raise  `StopAsync` `Iteration`  when finished. **Async Iterators: async for ** **| ** **51**
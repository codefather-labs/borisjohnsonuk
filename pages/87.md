### Streams (Standard Library)
 Before looking at third-party libraries, let’s begin with the standard library. The streams API  is the high-level interface offered for async socket programming, and as the following case study will show, it’s pretty easy to use. However, application design remains complex simply because of the nature of the domain. The following case study shows an implementation of a message broker, with an initial naive design followed by a more considered design. Neither should be considered production-ready; my goal is to help you think about the various aspects of concurrent network programming that need to be taken into account when designing such applications. #### Case Study: A Message Queue
 A  *message queue service*  is a backend application that receives connections from other applications and passes messages between those connected services, often referred to as  *publishers*  and  *subscribers* . Subscribers typically listen to specific channels for messages, and usually it is possible to configure the message distribution in different channels in two ways: messages can be distributed to all subscribers on a channel ( *pub-sub* ), or a different message can go to each subscriber one at a time ( *point-topoint* ). Recently, I worked on a project that involved using  ActiveMQ  as a message broker for microservices intercommunication. At a basic level, such a broker (server): •  Maintains persistent socket connections to multiple clients •  Receives messages from clients with a target  *channel name* •  Delivers those messages to all  *other*  clients subscribed to that same channel name I recall wondering how hard it might be to create such an application. As an added touch, ActiveMQ can perform both models of message distribution, and the two models are generally differentiated by the channel name: •  Channel names with the prefix  `/topic`  (e.g.,  `/topic/customer/registration` ) are managed with the  pub-sub  pattern, where all channel subscribers get all messages. •  Channel names with the prefix  `/queue`  are handled with the  point-to-point model, in which messages on a channel are distributed between channel subscribers in a round-robin fashion: each subscriber gets a unique message. In our case study, we will build a toy message broker with these basic features. The first issue we must address is that TCP is not a message-based protocol: we just get streams of bytes on the wire. We need to create our own protocol for the structure of **76 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
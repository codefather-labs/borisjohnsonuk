Subinterpreters You can refactor the  check_port()  function into an async generator that yields the next open port until it hits the last port, or it has found a speciﬁed number of open ports: async def  check_ports(host: str, start: int, end: int, max = 10 ): found  =  0 for  port  in  range(start, end): try : future  =  asyncio.open_connection(host = host, port = port) r, w  =  await  asyncio.wait_for(future, timeout = timeout) yield  port found  +=  1 w.close() if  found  >=  max: return except  asyncio. TimeoutError : pass  # closed To execute this, use the  async for  statement: async def  scan(start, end, host): results  =  [] async for  port  in  check_ports(host, start, end, max = 1 ): results.append(port) return  results See  cpython-book-samples 33 portscanner_async_generators.py  for the full example. 
#Subinterpreters 

 So far, you have covered: • Parallel execution with multiprocessing • Concurrent execution with threads and async The downside of multiprocessing is that the inter-process communication using pipes and queues is slower than shared memory. Also 282
`def` ` ` `handler` `(` `sig` `):` `    ` `loop` ` ` `=` ` ` `asyncio` `.` `get_running_loop` `()` `    ` `for` ` ` `task` ` ` `in` ` ` `asyncio` `.` `all_tasks` `(` `loop` `=` `loop` `):` `  ` `        ` `task` `.` `cancel` `()` `    ` `print` `(` `f` `'Got signal: ` `{sig!s}` `, shutting down.'` `)` `    ` `loop` `.` `remove_signal_handler` `(` `SIGTERM` `)` `    ` `loop` `.` `add_signal_handler` `(` `SIGINT` `,` ` ` `lambda` `:` ` ` `None` `)` `if` ` ` `__name__` ` ` `==` ` ` `'__main__'` `:` `    ` `asyncio` `.` `run` `(` `main` `())` Because  `asyncio.run()`  takes control of the event loop startup, our first opportunity to change signal handling behavior will be in the  `main()`  function. Inside the signal handler, we can’t stop the loop as in previous examples, because we’ll get warnings about how the loop was stopped before the task created for `main()`  was completed. Instead, we can initiate task cancellation here, which will ultimately result in the  `main()`  task exiting; when that happens, the cleanup handling inside  `asyncio.run()`  will take over. #### Waiting for the Executor During Shutdown
 “Quickstart” on page 22  introduced the basic executor interface with  Example 3-3 , where I pointed out that the blocking  `time.sleep()`  call was conveniently shorter than the  `asyncio.sleep()`  call—luckily for us, because it means the executor task completes sooner than the  `main()`  coroutine, and as a result the program shuts down correctly. This section examines what happens during shutdown when executor jobs take longer to finish than all the pending  `Task`  instances. The short answer is: without intervention, you’re going to get errors like those produced by the code in Example 3-36 . *Example 3-36. * *The* * executor takes too long to * *finish* `# quickstart.py` `import` ` ` `time` `import` ` ` `asyncio` `async` ` ` `def` ` ` `main` `():` `    ` `loop` ` ` `=` ` ` `asyncio` `.` `get_running_loop` `()` `    ` `loop` `.` `run_in_executor` `(` `None` `,` ` ` `blocking` `)` `    ` `print` `(` `f` `'{time.ctime()} Hello!'` `)` `    ` `await` ` ` `asyncio` `.` `sleep` `(` `1.0` `)` `    ` `print` `(` `f` `'{time.ctime()} Goodbye!'` `)` `def` ` ` `blocking` `():` **68 ** **| ** **Chapter 3: Asyncio Walk-Through**
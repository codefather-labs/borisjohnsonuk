a coroutine or a  `Future`  and you need to do something to it that requires you to have a `Future` . —Guido van Rossum,  commenting  on  issue #477 In sum,  `asyncio.ensure_future()`  is a helper function intended for framework designers. This is easiest to explain by analogy to a much more common kind of function, so let’s do that. If you have a few years’ programming experience behind you, you may have seen functions similar to the  `listify()`  function in  Example 3-19 . *Example 3-19. A utility function for coercing input into a list* `def` ` ` `listify` `(` `x` `:` ` ` `Any` `)` ` ` `->` ` ` `List` `:` `    ` `""" Try hard to convert x into a list """` `    ` `if` ` ` `isinstance` `(` `x` `,` ` ` `(` `str` `,` ` ` `bytes` `)):` `        ` `return` ` ` `[` `x` `]` `    ` `try` `:` `        ` `return` ` ` `[` `_` ` ` `for` ` ` `_` ` ` `in` ` ` `x` `]` `    ` `except` ` ` `TypeError` `:` `        ` `return` ` ` `[` `x` `]` This function tries to convert the argument into a list, no matter what comes in. These kinds of functions are often used in APIs and frameworks to coerce inputs into a known type, which simplifies subsequent code—in this case, you know that the parameter (output from  `listify()` ) will always be a list. If I rename the  `listify()`  function to  `ensure_list()` , then you should begin to see the parallel with  `asyncio.ensure_future()` : it tries to always coerce the argument into a  `Future`  (or subclass) type. This is a utility function to make life easier for *framework developers* , not end-user developers like you and I. Indeed, the  `asyncio`  standard library module itself uses  `ensure_future()`  for exactly this reason. When next you look over the API, everywhere you see a function parameter described as “awaitable objects,” it is likely that internally  `ensure_future()`  is being used to coerce the parameter. For example, the  `asyncio.gather()`  function has the following signature: `asyncio` `.` `gather` `(` `*` `aws` `,` ` ` `loop` `=` `None` `,` ` ` `...` `)` The  `aws`  parameter means “awaitable objects,” which includes coroutines, tasks, and futures. Internally,  `gather()`  is using  `ensure_future()`  for type coercion: tasks and futures are left untouched, while tasks are created for coroutines. The key point here is that as an end-user application developer, you should never need to use  `asyncio.ensure_future()` . It’s more a tool for framework designers. If you need to schedule a coroutine on the event loop, just do that directly with `asyncio.create_task()` . **Tasks and Futures ** **| ** **45**
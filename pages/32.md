#### CHAPTER 3
 ### Asyncio Walk-Through
 Asyncio provides another tool for concurrent programming in Python, that is more lightweight than threads or multiprocessing. In a very simple sense it does this by having an event loop execute a collection of tasks, with a key difference being that each task chooses when to yield control back to the event loop. —Philip Jones,  “Understanding Asyncio” The  `asyncio`  API in Python is complex because it aims to solve different problems for different groups of people. Unfortunately, very little guidance is available to help you figure out which parts of  `asyncio`  are important for the group  *you’re*  in. My goal is to help you figure that out. There are two main target audiences for the async features in Python: *End-user developers* These want to make applications using  `asyncio` . I am going to assume that you’re in this group. *Framework developers* These want to make frameworks and libraries that end-user developers can use in their applications. Much of the confusion around  `asyncio`  in the community today is due to lack of understanding of this difference. For instance, the official Python documentation for `asyncio`  is more appropriate for framework developers than end users. This means that end-user developers reading those docs quickly become shell-shocked by the apparent complexity. You’re somewhat forced to take it all in before being able to do anything with it. **21**
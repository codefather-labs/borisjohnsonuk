`2017-10-02 08:09:56 - (sanic): Goin' Fast @ http://0.0.0.0:8001` `2017-10-02 08:09:56 - (sanic): Starting worker [385]` Both instances, of course, connect to the same database. Now, with both API server instances running, let’s modify the data for patron  *John* , who clearly lacks sufficient Spam in his diet. Here we perform an  `UPDATE`  against the first app instance at port 8000: `$ curl -d '{"name": "John Cleese", "fav_dish": "SPAM on toast"}' \` `    -H "Content-Type: application/json" \` `    -X PUT \` `    http://localhost:8000/patron/29` `{"msg":"ok"}` Immediately after this update event on only one of the app instances,  *both*  API servers, 8000 and 8001, report the event in their respective logs: `2019-10-02 08:35:49 - (perf)[INFO]: Got DB event:` `{` `    "table": "patron",` `    "id": 29,` `    "type": "UPDATE",` `    "data": {` `        "old": {` `            "id": 29,` `            "name": "John Cleese",` `            "fav_dish": "Gravy on Toast"` `        },` `        "new": {` `            "id": 29,` `            "name": "John Cleese",` `            "fav_dish": "SPAM on toast"` `        },` `        "diff": {` `            "fav_dish": "SPAM on toast"` `        }` `    }` `}` The database has reported the update event back to both app instances. We haven’t done any requests against app instance 8001 yet, though—does this mean that the new data is already cached there? To check, we can do a  `GET`  on the second server, at port 8001: `$ curl -X GET http://localhost:8001/patron/29` `{"id":29,"name":"John Cleese","fav_dish":"SPAM on toast"}` The timing info in the log output shows that we do indeed obtain the data directly from the cache, even though this is our first request: `2019-10-02 08:46:45 - (perf)[INFO]: get Elapsed: 0.04 ms` **asyncpg and Sanic ** **| ** **119**
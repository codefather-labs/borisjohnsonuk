Coroutines Coroutines were initially available via a decorator, but this has since been deprecated in favor of “native” coroutines using the keywords async  and  await . To mark that a function returns a coroutine, it must be preceded with the  async  keyword. The  async  keyword makes it explicit (unlike generators) that this function returns a coroutine and not a value. To create a coroutine, deﬁne a function with the keyword  async def . In this example, add a timer using the  asyncio.sleep()  function and return a wake-up string: >>>  import  asyncio >>>  async def  sleepy_alarm(time): ... await  asyncio.sleep(time) ... return  "wake up!" >>>  alarm  =  sleepy_alarm( 10 ) >>>  alarm < coroutine object sleepy_alarm at  0x1041de340 > When you call the function, it returns a coroutine object. There are many ways to execute a coroutine. The easiest is using asyncio.run(coro) . Run  asyncio.run()  with your coroutine object, then after 10 seconds it will sound the alarm: >>>  asyncio.run(alarm) 'wake up' So far, there is a small beneﬁt over a regular function. The beneﬁt of coroutines is that you can run them concurrently. Because the coroutine object is a variable that you can pass to a function, these objects can be linked together and chained, or created in a sequence. For example, if you wanted to have 10 alarms with diﬀerent intervals and start them all at the same time, these coroutine objects can be 277
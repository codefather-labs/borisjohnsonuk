Our toy message broker works. The code is also pretty easy to understand, given such a complex problem domain, but unfortunately, the design of the broker code itself is problematic. The problem is that, for a particular client, we send messages to subscribers in the same coroutine as where new messages are received. This means that if any subscriber is slow to consume what we’re sending, it might take a long time for that `await gather(...)`  line in  Example 4-2  to complete, and we cannot receive and process more messages while we wait. Instead, we need to decouple the receiving of messages from the sending of messages. In the next case study, we refactor our code to do exactly that. #### Case Study: Improving the Message Queue
 In this case study, we improve the design of our toy message broker. The listener and sender programs remain as is. The specific improvement in the new broker design is to decouple sending and receiving messages; this will resolve the problem where a slow subscriber would also slow down receiving new messages, as discussed in the previous section. The new code, shown in  Example 4-9 , is a bit longer but not terribly so. *Example 4-9. Message broker: improved design* `# mq_server_plus.py` `import` ` ` `asyncio` `from` ` ` `asyncio` ` ` `import` ` ` `StreamReader` `,` ` ` `StreamWriter` `,` ` ` `Queue` `from` ` ` `collections` ` ` `import` ` ` `deque` `,` ` ` `defaultdict` `from` ` ` `contextlib` ` ` `import` ` ` `suppress` `from` ` ` `typing` ` ` `import` ` ` `Deque` `,` ` ` `DefaultDict` `,` ` ` `Dict` `from` ` ` `msgproto` ` ` `import` ` ` `read_msg` `,` ` ` `send_msg` `SUBSCRIBERS` `:` ` ` `DefaultDict` `[` `bytes` `,` ` ` `Deque` `]` ` ` `=` ` ` `defaultdict` `(` `deque` `)` `SEND_QUEUES` `:` ` ` `DefaultDict` `[` `StreamWriter` `,` ` ` `Queue` `]` ` ` `=` ` ` `defaultdict` `(` `Queue` `)` `CHAN_QUEUES` `:` ` ` `Dict` `[` `bytes` `,` ` ` `Queue` `]` ` ` `=` ` ` `{}` `  ` `async` ` ` `def` ` ` `client` `(` `reader` `:` ` ` `StreamReader` `,` ` ` `writer` `:` ` ` `StreamWriter` `):` `  ` `peername` ` ` `=` ` ` `writer` `.` `get_extra_info` `(` `'peername'` `)` `  ` `subscribe_chan` ` ` `=` ` ` `await` ` ` `read_msg` `(` `reader` `)` `  ` `SUBSCRIBERS` `[` `subscribe_chan` `]` `.` `append` `(` `writer` `)` `  ` `  ` `send_task` ` ` `=` ` ` `asyncio` `.` `create_task` `(` `      ` `send_client` `(` `writer` `,` ` ` `SEND_QUEUES` `[` `writer` `]))` `  ` `  ` `print` `(` `f` `'Remote ` `{peername}` ` subscribed to ` `{subscribe_chan}` `'` `)` `  ` `try` `:` `    ` `while` ` ` `channel_name` ` ` `:` `=` ` ` `await` ` ` `read_msg` `(` `reader` `):` `      ` `data` ` ` `=` ` ` `await` ` ` `read_msg` `(` `reader` `)` `      ` `if` ` ` `channel_name` ` ` `not` ` ` `in` ` ` `CHAN_QUEUES` `:` `  ` `        ` `CHAN_QUEUES` `[` `channel_name` `]` ` ` `=` ` ` `Queue` `(` `maxsize` `=` `10` `)` `  ` **84 ** **| ** **Chapter 4: 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)**
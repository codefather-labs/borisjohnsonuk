Assembly for  (i = a.a_nblocks -  1 ; i >=  0 ; i--) { b = a.a_postorder[i]; for  (j =  0 ; j < b->b_iused; j++) if  (!assemble_emit(&a, &b->b_instr[j])) goto  error; } ... co = makecode(c, &a); error: assemble_free(&a); return  co; } 
##Depth-First-Search 

 The depth-ﬁrst-search is performed by the  dfs()  function in  Python compile.c , which follows the the  b_next  pointers in each of the blocks, marks them as seen by toggling  b_seen  and then adds them to the assemblers’  a_postorder  list in reverse order. The function loops back over the assembler’s post-order list and for each block, if it has a jump operation, recursively call  dfs()  for that jump: Python compile.c  line 5436 static void dfs( struct  compiler *c, basicblock *b,  struct  assembler *a,  int  end) { int  i, j; /* Get rid of recursion for normal control flow. Since the number of blocks is limited, unused space in a_postorder (from a_nblocks to end) can be used as a stack for still not ordered blocks. */ for  (j = end; b && !b->b_seen; b = b->b_next) { b->b_seen =  1 ; 142
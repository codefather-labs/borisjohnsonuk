
![page_72_0](images/page_72_0.png)
 `$ ` `python telnetdemo.py` `New connection.` `^C` `Connection dropped!` `Bye!` `Task was destroyed but it is pending!` `task: <Task pending name='Task-6' coro=<send_event() done, ...>` To understand why this is happening, we must go back to the sequence of cleanup events that  `asyncio.run()`  does during the shutdown phase; in particular, the important part is that when we press Ctrl-C, all the currently active tasks are collected and cancelled. At this point,  *only those tasks*  are then awaited, and  `asyncio.run()`  returns immediately after that. The bug in our modified code is that we created a  *new*  task inside the cancellation handler of our existing “echo” task. This new task was created only after  `asyncio.run()`  had collected and cancelled all the tasks in the process. This is why it is important to be aware of how  `asyncio.run()`  works. As a general rule of thumb, try to avoid creating new tasks inside `CancelledError`  exception handlers. If you must, be sure to also `await`  the new task or future inside the scope of the same function. And finally: if you’re using a library or framework, make sure to follow its documentation on how you should perform startup and shutdown. Third-party frameworks usually provide their own functions for startup and shutdown, and they’ll provide event hooks for customization. You can see an example of these hooks with the Sanic framework in  “Case Study: Cache Invalidation” on page 115 . #### What Is the return_exceptions=True for in gather()?
 You may have noticed the keyword argument  `return_exceptions=True`  in the call to `gather()`  in Examples  3-3  and  3-1  during the shutdown sequence, but I very sneakily said nothing about it at the time.  `asyncio.run()`  also uses  `gather()`  and `return_exceptions=True`  internally, and the time has come for further discussion. Unfortunately, the default is  `gather(..., return_exceptions=False` ). This default is problematic for most situations, including the shutdown process, and this is why `asyncio.run()`  sets the parameter to  `True` . It’s a little complicated to explain directly; instead, let’s step through a sequence of observations that’ll make it much easier to understand: 1. ` run_until_complete()`  operates on a future; during shutdown, it’s the future returned by  `gather()` . **Starting Up and Shutting Down (Gracefully!) ** **| ** **61**
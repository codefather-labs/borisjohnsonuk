Coroutines sult, and the  print()  function is able to execute. For this to work,  asyncio.sleep()  must be used instead of the blocking (and not async-aware)  time.sleep() . 
##Example 

 You can convert the multithreaded port scanner example to asyncio with these steps: • Change the  check_port()  function to use a socket connection from asyncio.open_connection() , which creates a future instead of an immediate connection • Use the socket connection future in a timer event, with asyncio.wait_for() • Append the port to the results list if succeeded • Add a new function,  scan()  to create the  check_port()  coroutines for each port and add them to a list,  tasks • Merge all the tasks into a new coroutine using  asyncio.gather() • Run the scan using  asyncio.run() cpython-book-samples 33 portscanner_async.py import  time import  asyncio timeout  =  1.0 async def  check_port(host: str, port: int, results: list): try : future  =  asyncio.open_connection(host = host, port = port) r, w  =  await  asyncio.wait_for(future, timeout = timeout) results.append(port) w.close() except  asyncio. TimeoutError : pass # port is closed, skip-and-continue 280
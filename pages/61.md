9  Yes, this is super annoying. Every time I use this call, I can’t help wondering why the more common idiom of using  `executor=None`  as a keyword argument was not preferred. `    ` `await` ` ` `loop` `.` `run_in_executor` `(` `None` `,` ` ` `update_stats` `,` ` ` `url` `)` `  ` `async` ` ` `with` ` ` `web_page` `(` `'google.com'` `)` ` ` `as` ` ` `data` `:` `    ` `process` `(` `data` `)` For this example, assume that we are  *unable*  to modify the code for our two blocking calls,  `download_webpage()`  and  `update_stats()` ; i.e., we can’t alter them to be coroutine functions. That’s bad, because the most grave sin of eventbased programming is breaking the rule that you must never, under any circumstances, prevent the event loop from processing events. To get around the problem, we will use an  *executor*  to run the blocking calls in a separate thread. The executor is made available to us as an attribute of the event loop itself. We call the executor. The signature is  `AbstractEventLoop.run_in_execu` `tor` ( `executor` ,  `func` ,  `*args` ). If you want to use the default executor (which is a `ThreadPoolExecutor` ), you must pass  `None`  as the value for the  `executor` argument. 9 As with the call to  `download_webpage()` , we also run the other blocking call to `update_stats()`  in an executor. Note that you  *must*  use the  `await`  keyword in front. If you forget, the execution of the asynchronous generator (i.e., your async context manager) will not wait for the call to complete before proceeding. It’s likely that async context managers are going to be heavily used in many  `asyncio` -based codebases, so it’s pretty important to have a good understanding of them. You can read more about the new  `@asynccontextmanager`  decorator in the  Python 3.7 documentation . ### Async Iterators: async for
 Next up is the async version of the  `for`  loop. It is easiest to understand how this works if you first recognize that ordinary iteration—just like so many other language features—is implemented through the use of  *special methods* , recognizable by the double underscores in their names. For reference,  Example 3-24  shows how a standard (nonasync) iterator is defined through the use of the  `__iter__()`  and  `__next__()`  methods. **50 ** **| ** **Chapter 3: Asyncio Walk-Through**
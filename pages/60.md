8  Async support can be quite difficult to add to an existing framework after the fact since large structural changes to the codebase might be needed. This was discussed in a  GitHub issue for  `requests` . Note that the presence of  `yield`  is what changes a function into a  *generator function* ; the additional presence of the  `async def`  keywords in point 1 makes this an *asynchronous generator function* . When called, it will return an  *asynchronous generator* . The  `inspect`  module has two functions that can test for these: `isasyncgenfunction()`  and  `isasyncgen()` , respectively. Here, assume that we’ve also converted the code inside the  `update_stats()`  function to allow it to produce coroutines. We can then use the  `await`  keyword, which allows a context switch to the event loop while we wait for the I/O-bound work to complete. Another change was required in the usage of the context manager itself: we needed to use  `async with`  instead of a plain  `with` . Hopefully, this example shows that the new  `@asynccontextmanager`  is perfectly analogous to the  `@contextmanager`  decorator. In callouts 3 and 5, I said it was necessary to modify some functions to return coroutines; these were  `download_webpage()`  and  `update_stats()` . This is usually not that easy to do, since async support needs to be added down at the socket level. The focus of the preceding examples was simply to show off the new `@asynccontextmanager`  decorator, not to show how to convert blocking functions into nonblocking ones. The more common situation is when you want to use a blocking function in your program, but it’s not possible to modify the code in that function. This situation will usually happen with third-party libraries, and a great example is the  `requests`  library, which uses blocking calls throughout. 8  If you can’t change the code being called, there is another way. This is a convenient place to show you how an  *executor*  can be used to do exactly that, as illustrated in  Example 3-23 . *Example 3-23. * *The* * nonblocking-with-a-little-help-from-my-friends way* `from` ` ` `contextlib` ` ` `import` ` ` `asynccontextmanager` `@asynccontextmanager` `async` ` ` `def` ` ` `web_page` `(` `url` `):` `  ` `    ` `loop` ` ` `=` ` ` `asyncio` `.` `get_event_loop` `()` `    ` `data` ` ` `=` ` ` `await` ` ` `loop` `.` `run_in_executor` `(` `        ` `None` `,` ` ` `download_webpage` `,` ` ` `url` `)` `  ` `    ` `yield` ` ` `data` **Async Context Managers: async with ** **| ** **49**
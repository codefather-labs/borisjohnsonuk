Example: Implementing the “Almost-Equal” Operator case  Py_LT:  if  ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE; case  Py_GT:  if  ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE; case  Py_LE:  if  ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE; case  Py_GE:  if  ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE; /* + */  case  Py_AlE:  if  ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE; default : Py_UNREACHABLE(); } }  while  ( 0 ) Inside  Objects object.c  there is a guard to check that the operator is within the range 0-5, because you added the value 6 you have to update that assertion: Objects object.c  line 709 PyObject * PyObject_RichCompare(PyObject *v, PyObject *w,  int  op) { PyThreadState *tstate = _PyThreadState_GET(); assert(Py_LT <= op && op <= Py_GE); Change that last line to: assert(Py_LT <= op && op <= Py_AlE); Next, you need to update the  COMPARE_OP  opcode to support  Py_AlE  as a value for the operator type. First, edit  Objects object.c  and add  Py_AlE  into the  _Py_SwappedOp  list. This list is used for matching whether a custom class has one operator dunder method, but not the other. For example, if you deﬁned a class,  Coordinate , you could deﬁne an equality operator by implementing the  __eq__  magic-method: class  Coordinate: def  __init__ ( self , x, y): 148
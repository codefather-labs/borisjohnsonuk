Core Compilation Process If you import  dis  and give the  dis()  function the code object’s  co_code property it disassembles it and prints the instructions on the REPL: >>>  import  dis >>>  dis.dis(co.co_code) 0  LOAD_NAME 0  ( 0 ) 2  LOAD_CONST 0  ( 0 ) 4  BINARY_ADD 6  RETURN_VALUE LOAD_NAME ,  LOAD_CONST ,  BINARY_ADD , and  RETURN_VALUE  are all bytecode instructions. They’re called bytecode because, in binary form, they were a byte long. However, since Python 3.6 the storage format was changed to a  word , so now they’re technically wordcode, not bytecode. The  full list of bytecode instructions  is available for each version of Python, and it does change between versions. For example, in Python 3.7, some new bytecode instructions were introduced to speed up execution of speciﬁc method calls. In earlier chapters, you explored the  instaviz  package. This included a visualization of the code object type by running the compiler. It also displays the bytecode operations inside the code objects. Execute instaviz again to see the code object and bytecode for a function deﬁned on the REPL: >>>  import  instaviz >>>  def  example(): a  =  1 b  =  a  +  1 return  b >>>  instaviz.show(example) 
##Compiler C API 

 The entry point for AST module compilation,  compiler_mod() , switches to diﬀerent compiler functions depending on the module type. If you assume that  mod  is a  Module , the module is compiled into the 133
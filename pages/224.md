Conclusion You can also get the current threshold counts: >>>  gc.get_count() ( 688 ,  1 ,  1 ) Lastly, you can run the collection algorithm manually for a generation, and it will return the collected total: >>>  gc.collect( 0 ) 24 If you don’t specify a generation, it will default to  2 , which merges generations  0  and  1 : >>>  gc.collect() 20 
#Conclusion 

 In this chapter, you’ve been shown how CPython allocates, manages, and frees memory. These operations happen 1000s of times during the lifecycle of even the simplest Python script. The reliability and scalability of CPython’s Memory Management system are what enables it to scale from a 2-line script all the way to run some of the world’s biggest websites. The Object and Raw Memory Allocation systems you’ve been shown in this chapter will come in useful if you develop C extension modules. C extension modules require an intimate knowledge of CPython’s Memory Management system. Even a single missing  Py_INCREF()  can cause a memory leak or system crash. When working with pure Python code, knowledge of the GC is useful if you’re designing long-running Python code. For example, if you designed a single function that executes over hours, days, or even longer. This function would need to carefully manage its memory within the constraints of the system on which it’s executing. You can use some of the techniques learned in this chapter to control and tweak the GC 224
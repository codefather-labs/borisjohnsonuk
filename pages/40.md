At the most fundamental level, Tier 1, we have the coroutines that you’ve already seen earlier in this book. This is the lowest level at which one can begin to think about designing a third-party framework, and surprisingly, this turns out to be somewhat popular with not one, but  *two* , async frameworks currently available in the wild: Curio  and  Trio . Both of these rely  *only*  on native coroutines in Python, and nothing whatsoever from the  `asyncio`  library module. The next level is the event loop. Coroutines are not useful by themselves: they won’t do anything without a loop on which to run them (therefore, necessarily, Curio and Trio implement their own event loops).  `asyncio`  provides both a loop  *specification* , `AbstractEventLoop` , and an  *implementation* ,  `BaseEventLoop` . The clear separation between specification and implementation makes it possible for third-party developers to make alternative implementations of the event loop, and this has already happened with the  uvloop  project, which provides a much faster loop implementation than the one in the  `asyncio`  standard library module. Importantly, uvloop simply “plugs into” the hierarchy and replaces  *only*  the loop part of the stack. The ability to make these kinds of choices is exactly why the  `asyncio`  API has been designed like this, with clear separation between the moving parts. Tiers 3 and 4 bring us futures and tasks, which are very closely related; they’re separated only because  `Task`  is a subclass of  `Future` , but they could easily be considered to be in the same tier. A  `Future`  instance represents some sort of ongoing action that will return a result via  *notification*  on the event loop, while a  `Task`  represents a coroutine running on the event loop. The short version is: a future is “loop-aware,” while a task is both “loop-aware”  *and*  “coroutine-aware.” As an end-user developer, you will be working with tasks much more than futures, but for a framework designer, the proportion might be the other way around, depending on the details. Tier 5 represents the facilities for launching, and awaiting on work that must be run in a separate thread, or even in a separate process. Tier 6 represents additional async-aware tools such as  `asyncio.Queue` . I could have placed this tier after the network tiers, but I think it’s neater to get all of the coroutine-aware APIs out of the way first, before we look at the I/O layers. The  `Queue` provided by  `asyncio`  has a very similar API to the thread-safe  `Queue`  in the  `queue` module, except that the  `asyncio`  version requires the  `await`  keyword on  `get()`  and `put()` . You cannot use  `queue.Queue`  directly inside coroutines because its  `get()`  will block the main thread. Finally, we have the network I/O tiers, 7 through 9. As an end-user developer, the most convenient API to work with is the streams API at Tier 9. I have positioned the streams API at the highest level of abstraction in the tower. The protocols API, immediately below that (Tier 8), is a more fine-grained API; you  *can*  use the protocols tier in all instances where you might use the streams tier, but using streams will **The Tower of Asyncio ** **| ** **29**
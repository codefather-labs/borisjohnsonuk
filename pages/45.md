6  Also acceptable is a legacy, generator-based coroutine, which is a generator function that is decorated with `@types.coroutine`  and uses the  `yield from`  keyword internally to suspend. We are going to completely ignore legacy coroutines in this book. Erase them from your mind! When the coroutine  *returns* , a special kind of exception is raised, called  `StopIter` `ation` . Note that we can access the return value of the coroutine via the  `value` attribute of the exception itself. Again, you don’t need to know that it works like this: from your point of view,  `async def`  functions will simply return a value with the  `return`  statement, just like normal functions. These two points, the  `send()`  and the  `StopIteration` , define the start and end of the executing coroutine, respectively. So far this just seems like a really convoluted way to run a function, but that’s OK: the  *event loop*  will be responsible for driving coroutines with these low-level internals. From your point of view, you will simply schedule coroutines for execution on the loop, and they will get executed top-down, almost like normal functions. The next step is to see how the execution of the coroutine can be suspended. #### The New await Keyword
 This new keyword  `await`  always takes a parameter and will accept  *only*  a thing called an  *awaitable* , which is defined as one of these (exclusively!): •  A coroutine (i.e., the  *result*  of a called  `async def`  function). 6 •  Any object implementing the  `__await__()`  special method. That special method *must*  return an iterator. The second kind of awaitable is out of scope for this book (you’ll never need it in dayto-day  `asyncio`  programming), but the first use case is pretty straightforward, as Example 3-7  shows. *Example 3-7. Using await on a coroutine* `async` ` ` `def` ` ` `f` `():` `    ` `await` ` ` `asyncio` `.` `sleep` `(` `1.0` `)` `    ` `return` ` ` `123` `async` ` ` `def` ` ` `main` `():` `    ` `result` ` ` `=` ` ` `await` ` ` `f` `()` `  ` `    ` `return` ` ` `result` Calling  `f()`  produces a coroutine; this means we are allowed to  `await`  it. The value of the  `result`  variable will be  `123`  when  `f()`  completes. **34 ** **| ** **Chapter 3: Asyncio Walk-Through**
Multi-Process Parallelism def  spawn_main(pipe_handle, parent_pid = None , tracker_fd = None ): ''' Run code specified by data received over pipe ''' assert  is_forking(sys.argv),  "Not forking" For Windows, the function will call the  OpenProcess  API  of the parent PID. This process object is used to create a ﬁlehandle,  fd , of the parent process pipe: if  sys.platform  ==  'win32' : import  msvcrt import  _winapi if  parent_pid  is not  None : source_process  =  _winapi.OpenProcess( _winapi.SYNCHRONIZE  |  _winapi.PROCESS_DUP_HANDLE, False , parent_pid) else : source_process  =  None new_handle  =  reduction.duplicate(pipe_handle, source_process = source_process) fd  =  msvcrt.open_osfhandle(new_handle, os.O_RDONLY) parent_sentinel  =  source_process For POSIX, the  pipe_handle  becomes the ﬁle descriptor,  fd , and is duplicated to become the  parent_sentinel  value: else : from  .  import  resource_tracker resource_tracker._resource_tracker._fd  =  tracker_fd fd  =  pipe_handle parent_sentinel  =  os.dup(pipe_handle) Next, the  _main()  function is called with the parent pipe ﬁle handle, fd , and the parent process sentinel,  parent_sentinel . Whatever the return value of  _main()  is becomes the exit code for the process and the 240
Example: Adding an Item to a List ... case  TARGET(LOAD_FAST): { PyObject *value = GETLOCAL(oparg); // 1. if  (value == NULL) { format_exc_check_arg( PyExc_UnboundLocalError, UNBOUNDLOCAL_ERROR_MSG, PyTuple_GetItem(co->co_varnames, oparg)); goto  error; // 2. } Py_INCREF(value); // 3. PUSH(value); // 4. FAST_DISPATCH(); // 5. } ... The pointer to  obj  is now at the top of the value stack, and the next instruction,  LIST_APPEND , is executed. Many of the bytecode operations are referencing the base types, like PyUnicode ,  PyNumber . For example,  LIST_APPEND  appends an object to the end of a list. To achieve this, it pops the pointer from the value stack and returns the pointer to the last object in the stack. The macro is a shortcut for: PyObject *v = (*--stack_pointer); Now the pointer to  obj  is stored as  v . The list pointer is loaded from PEEK(oparg) . Then the C API for Python lists is called for  list  and  v . The code for this is inside  Objects listobject.c , which you go into in the chapter Objects and Types. A call to  PREDICT  is made, which guesses that the next operation will be  JUMP_ABSOLUTE . The  PREDICT  macro has compiler-generated  goto statements for each of the potential operationsâ€™  case  statements. This means the CPU can jump to that instruction and not have to go through the loop again: 176